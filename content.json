{"pages":[],"posts":[{"title":"JS原型梳理","text":"一、原型链图解 function Foo就是一个方法，比如JavaScript 中内置的Array、String等 function Object就是一个Object function Function就是Function 以上都是function，所以__proto__都是Function.prototype String、Array、Number、Function、Object都是function二、函数对象和普通对象 在 JavaScript 中，我们将对象分为函数对象和普通对象。所谓的函数对象，其实就是 JavaScript 的用函数来模拟的类实现。JavaScript 中的 Object 和 Function 就是典型的函数对象。 不知道大家看到上述代码有没有一些疑惑的地方~别着急，我们一点一点梳理。 上述代码中，obj1，obj2，obj3，obj4都是普通对象，fun1，fun2，fun3都是Function的实例，也就是函数对象。 所以可以看出，所有 Function 的实例都是函数对象，其他的均为普通对象，其中包括 Function 实例的实例。 JavaScript 中万物皆对象，而对象皆出自构造（构造函数）。 三、proto首先需要明确两点：__proto__和constructor是对象独有的。prototype属性是函数独有的； 但是在 JavaScript 中，函数也是对象，所以函数也拥有__proto__和constructor属性。 ECMAScript 规范描述prototype是一个隐式引用，但之前的一些浏览器，已经私自实现了__proto__这个属性，使得可以通过obj.__proto__这个显式的属性访问，访问到被定义为隐式属性的prototype。 因此，情况是这样的，ECMAScript 规范说prototype应当是一个隐式引用: 通过Object.getPrototypeOf(obj)间接访问指定对象的prototype对象 通过Object.setPrototypeOf(obj, anotherObj)间接设置指定对象的prototype对象 部分浏览器提前开了__proto__的口子，使得可以通过obj.__proto__直接访问原型，通过obj.__proto__ = anotherObj直接设置原型 ECMAScript 2015 规范只好向事实低头，将__proto__属性纳入了规范的一部分 从浏览器的打印结果我们可以看出，上图对象a存在一个__proto__属性。而事实上，他只是开发者工具方便开发者查看原型的故意渲染出来的一个虚拟节点。虽然我们可以查看，但实则并不存在该对象上。 __proto__属性既不能被for in遍历出来，也不能被Object.keys(obj)查找出来。 访问对象的obj.__proto__属性，默认走的是Object.prototype对象上__proto__属性的 get/set 方法。 关于更多__proto__更深入的介绍，可以参看工业聚大佬的《深入理解 JavaScript 原型》一文。 这里我们需要知道的是，__proto__是对象所独有的，并且__proto__是一个对象指向另一个对象，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的__proto__属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的__proto__属性所指向的父类的父类上去查找。以此类推，知道找到null。而这个查找的过程，也就构成了我们常说的原型链。 四、prototype在规范里，prototype 被定义为：给其它对象提供共享属性的对象。prototype自己也是对象，只是被用以承担某个职能罢了. 所有对象，都可以作为另一个对象的prototype来用。 修改__proto__的关系图，我们添加了prototype,prototype是函数所独有的。它的作用就是包含可以给特定类型的所有实例提供共享的属性和方法。它的含义就是函数的远行对象，也就是这个函数所创建的实例的远行对象，正如上图：nealyang.__proto__ === Person.prototype。任何函数在创建的时候，都会默认给该函数添加prototype属性. 五、constructorconstructor属性也是对象所独有的，它是一个对象指向一个函数，这个函数就是该对象的构造函数。 注意，每一个对象都有其对应的构造函数，本身或者继承而来。单从constructor这个属性来讲，只有prototype对象才有。每个函数在创建的时候，JavaScript 会同时创建一个该函数对应的prototype对象，而函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其对应的构造函数。 唯一特殊的可能就是我开篇抛出来的一个问题。JavaScript 原型的老祖宗：Function。它是它自己的构造函数。所以Function.prototype === Function.__proto。 为了直观了解，我们在上面的图中，继续添加上constructor： 其中constructor属性，虚线表示继承而来的 constructor 属性。 __proto__介绍的原型链，我们在图中直观的标出来的话就是如下这个样子","link":"/2021/04/26/JS%E5%8E%9F%E5%9E%8B%E6%A2%B3%E7%90%86/"},{"title":"Three.js初探","text":"本次分享主要涉及以下知识点： 1、ThreeJS 框架中光源、相机、渲染器、几何体、材质以及场景等对象的相关知识并使用这些对象基于一个基础的程序结构构建出 3D 场景 2、右手坐标系、三角形网格等计算机图形学基础概念的相关知识 3、进一步学习 ThreeJS 框架以及 3D 相关知识 本次分享的目标： 希望大家通过本次分享能掌握Three.js的基础知识并能创建简单的3D场景 概述 WebGL是在浏览器中实现3D效果的一套规范，而最初使用WebGL原生的API来写3D程序是一件非常痛苦的事情，在辛苦的付出下WebGL开源框架出现了，其中three.js就是其中优秀的一个 ThreeJS是由 Ricardo Cabello 在 2010 年 4 月开源于 GitHub 的 3D 框架，基于这个框架我们可以直接使用 JavaScript 语言在网页中构建 3D 场景； 在开始构建 3D 场景之前，我们需要先了解几个名词 接下来通过一个比喻来了解这几个名词，我们为什么能看到这篇分享 首先你肯定拥有一台电子终端（电脑、手机或者其它），该电子终端渲染出文字并发出光线，接着人眼能接收光线，并在视网膜上成像，最终传送给大脑。 然后再仔细想一想上述过程中的关键因素是啥？ 文字：被观测物体； 能发出光线的电子终端：光源； 能接收光线的眼睛：相机； 视网膜：渲染器； 而正是因为 ThreeJS 框架提供了创建这些关键因素的能力所以我们才能使用它在计算机中构建 3D 场景。 基础程序结构 按照上边的理解，我们构建 3D 场景只需要创建四个关键因素即可，代码如下： 在页面加载完成之后，通过initRender()创建渲染器、initCamera()创建相机、initLight()创建光源、initObject()创建物体即可。 创建渲染器 视网膜的作用是成像，在 ThreeJS 框架中的渲染器起到相同的作用； ThreeJS 框架提供了好几种渲染器对象，分别使用不同的底层技术实现，比如： WebGLRenderer使用 WebGL 技术； CanvasRenderer使用 Canvas 2D 技术； CSS2DRenderer和CSS3DRenderer则是使用 CSS 技术； 不同渲染器具有不同的特点，简单来说 WebGLRenderer 最强大，CanvasRenderer、CSS2DRenderer 和 CSS3DRenderer 具有较好的兼容性但同时也有居多限制。 当前主流浏览器对 WebGL 支持情况良好，在大部分场景中我们都不需要考虑 CanvasRenderer、CSS2DRenderer 和 CSS3DRenderer 这些降级方案，因此示例中使用 WebGLRenderer； 调用new THREE.WebGLRenderer()即可创建一个 WebGL 渲染器对象，在初始化时可以传入一些参数，比如设置antialias为true即可开启 WebGL 渲染器的抗锯齿功能； 调用setSize方法可以设置渲染器的宽度和高度， 调用setClearColor方法则是设置背景颜色， 最后调用setPixelRatio方法设置设备像素比，用来处理手机等设备的高清屏幕； 最后需要把渲染器放置到页面中，为此需要一个容器，任意可以加入子元素的 DOM 元素均可，示例中用的是id属性为retina的div元素； 创建相机 相机的作用就类似于人眼，决定了观察的视角和位置； ThreeJS 框架同样提供了多种相机，比较常用有两种，分别为PerspectiveCamera透视投影相机和OrthographicCamera正交投影相机； 其中和人眼观察效果一致的是透视投影相机，用其观察物体时能获得近大远小的效果，因此示例中使用PerspectiveCamera； 调用new THREE.PerspectiveCamera(fov, aspect, near, far)即可创建一个透视投影相机，其参数意义如下： fov表示视角（视景体竖直方向上的张角）如侧视图； aspect表示裁切面宽高比（是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例）； near表示近平面距离； far表示远平面距离； 只有离相机的距离大于near且小于far，另外还得在相机视角内的物体，才能被相机观察到从而被渲染器渲染出来； 在设置相机位置、正方向以及视点时，需要基于某个三维坐标系；而在 ThreeJS 框架中我们一般使用的坐标系是当你面朝计算机屏幕时，X轴是水平的（正方向为右），Y轴是垂直的（正方向为上），Z轴垂直于屏幕（正方向为外），这个坐标系也被称为右手坐标系。 之所被称为右手坐标系是因为它是通过如图所示的右手手势确定的，即当你伸出右手摆出如图所示手势时，拇指指向X轴的正方向，食指指向Y轴的正方向，中指指向Z轴的正方向，这种确定坐标系方式也被称为右手定则。 相机的position属性决定其位置，调用set方法设置到点(200, 400, 600)位置； 相机的up属性表示相机的正方向，设置三维向量(0, 1, 0)也就是Y轴正方向为相机正方向，类似于人在直立观察；如果把相机正方向设置为Y轴负方向则类似于人在倒立观察。 Vector3是 ThreeJS 框架中的一个对象； 它具有三个属性，分别是x、y、z，这个属性既可以表示三维空间中的点也可以表示向量； 相机还有很重要的一个属性视点需要设置，也就是人眼的焦点，调用lookAt方法即可，参数为Vector3对象，点(0, 0, 0)表示坐标系原点。 创建光源 现实生活中能发光的物体多种多样，有太阳、手电筒以及灯泡等；ThreeJS 框架参考了现实中的各种发光物体封装实现了多种光源； 方向光 众所周知因为太阳距离地球的距离足够远，其光线可以近似看作平行光，对应 ThreeJS 框架中的DirectionalLight方向光； 从模拟太阳光照射正方体的例子中可以看到对于任意平行的平面，方向光照射的亮度都是相同的。 聚光灯 手电筒能够朝着一个方向投射类似圆锥形的光线，对应 ThreeJS 框架中的SpotLight聚光灯。 点光源 PointLight点光源则类似于灯泡，其发出的光线照到物体表面的亮度是线性递减的，因此离点光源距离越远的物体会显得越暗。 环境光 在阳光充足没有人造光源的室外，有很多物体能遮挡阳光形成阴影区域，这些阴影区域内的物体不能发光且并不能直接被阳光照射到，按道理应该是漆黑一片才对，但实际上这些阴影区域仅仅只是比周围暗一点而已；究其原因则是因为存在环境光，对应 ThreeJS 框架中的AmbientLight环境光； 环境光没有明确的光源位置，在各处形成的亮度也被看作是一致的，光照颜色会添加到整个场景和所有对象的当前颜色上。 示例中创建光源时使用了PointLight点光源和AmbientLight环境光： 调用new THREE.PointLight(color, intensity, distance, decay)即可创建一个点光源，其参数意义如下： color表示光照的颜色； intensity表示光照强度； distance表示最远的照射距离，超过该距离后不再有任何光线； decay表示光照的衰减程度，设置的越大则光照随着距离的增加衰减的越厉害； 示例中点光源颜色为白色，强度为1，最远光照距离为2000，位置被设置在点(70, 112, 98)； 在 ThreeJS 框架中有个非常基础的对象Object3D，该对象拥有position属性来表示其位置；框架中其它大部分对象都是由该对象扩展，比如上文中的PerspectiveCamera透视投影相机以及 PointLight点光源。 环境光只有一个颜色性质，直接调用new THREE.AmbientLight( 0x333333 )创建即可。 创建物体 ThreeJS 框架中封装实现了很多种几何体，例子中使用BoxGeometry，该对象可以用来创建正方体或者长方体； 示例中初始化BoxGeometry对象时只用了前三个参数，分别表示长、宽、高；但其实该对象还有三个参数： BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) widthSegments、heightSegments、depthSegments这三个参数共同决定了不同面由多少个三角形组成； 至于为什么正方体盒子会由很多三角形构成？可以类比于人在纸上手动画正方体，绘制正方体的过程其实就是在八个顶点间连线的过程，每四个顶点组成一个正方形面，最终由六个正方形面组成正方体； 在计算机中构建 3D 物体也是如此，只不过采用的是连接三个顶点组成三角形的方式而已，这个三角形在计算机图形学中被称为三角形网格； 一般来说网格面数越多，物体越精细，但同时会消耗更多的存储空间以及计算机性能。 之所以采用三角形网格则是因为三角形网格具有很多优点，比如三角形是最简单的多边形、三角形经过多种变换之后依然是三角形等等。 三角形网格只能描述物体的轮廓，但现实生活中的物体，人眼除了能看到其轮廓之外，还能看到其材质，比如一般情况下人能通过眼睛分辨出哪些金属哪些不是金属，因为金属和非金属对光的反射效果不一样；可以理解为材质主要是用来描述物体表面动态属性的对象，比如处理光照等。 示例中物体使用的是MeshLambertMaterial兰伯特材质，这是一种非光滑表面材质没有高亮的镜面反射，初始化时设置其颜色为红色； 最终轮廓和材质共同生成一个物体，并设置其中心点在坐标系原点。 虽然示例中并不涉及，但是仔细思考就能发现轮廓和材质并不能完全描述现实中的物体，比如同一种材质的纸可以被印上不同的图案，这种物体表面的静态属性使用纹理对象来描述。 另外还补充一点： 虽然在 ThreeJS 框架中提供了很多几何体对象，但是实际开发时针对一些复杂的物体或者动画依然需要使用特定的 3D 软件设计制作并导出模型素材，有点类似于在网页重构中有些图案、效果或者动画很难通过代码来实现，这时候就需要用到图片素材；图片有很多种格式，有些格式比如PNG、JPG是静态图片，有些格式比如GIF、APNG是动态图片，有些格式兼容性好，有些格式兼容差；3D 模型的情况也基本类似如此，由于目前了解不多就不过多展开了。 创建场景 到目前为止四个关键因素已经创建完成了，这时候执行代码会发现页面一片漆黑什么也没有； 之所以会这样是因为在 ThreeJS 框架中 ~/Workplace/xm   develop ↓688  ↵ 1  好关键因素之后需要把它们放入场景中，然后再执行渲染器的渲染方法； 因此需要在createWorld方法中新增两个方法，分别用来初始化场景以及执行渲染； 在 ThreeJS 框架中Scene对象表示场景； 创建场景时不需任何参数，直接执行new THREE.Scene()即可，然后还需要执行其add方法，把光源、物体添加到场景中； 渲染时需要先执行渲染器的clear方法清空上一次的渲染结果，然后再执行render方法，参数为场景对象以及相机对象； requestAnimationFrame是浏览器提供的动画函数，浏览器会在下次重绘前执行其回调函数； cube.rotation.x和cube.rotation.y的递增则是为了让方块在X轴和Y轴上不断旋转，从而形成动态的光影效果； 至此整个例子就结束了。 总结 上述内容非常基础，如果想要了解的更多，ThreeJS 框架使用的底层技术WebGL以及3D数学基础； 还可以去Three.js的官网https://threejs.org/上了解documentation和examples； 文档（ documentation ）包含框架中大部分对象的属性以及方法的说明信息，还一些新手入门的指引文档，比如：创建一个场景、画线、加载 3D 模型等； 例子（ examples ）顾名思义全是各种各样的例子，比如：衣服动画例子等； 后续的分享可能会继续讲解WebGL和3D数学基础，敬请期待，未完待续。。。","link":"/2021/04/27/Three-js%E5%88%9D%E6%8E%A2/"},{"title":"The Cure!","text":"最爱乐队推荐（The Cure）The Cure!!! THECURE是指治疗乐队，1978年成立 乐队目前的成员 robert smith : 主唱，吉他，键盘 simon galluo : 贝司 perry bamonte : 吉他，键盘 jason cooper : 鼓 roger o’donnell : 键盘 乐队的成员经历过无数次变化，目前的阵容是最新阵容。jason是1995年加入队伍，以顶替离队的boris williams。roger之前曾经离队，现有回到队中。 乐队原鼓手laurence tolhurst（1989 年离队）首先给乐队起了个名叫“easy cure”，这个名用了2年，在1978年，robret把她简化为the cure，因为他觉得“easy cure”这个名字太嘻皮，太美式。 风格类型： Alternative Pop/Rock（另类流行/摇滚） College Rock（学院摇滚） Goth Rock（哥特） New Wave（新浪潮） Post-Punk（后朋克） The Cure永远是一个伟大的名字！他们拥有”哥特音乐的教父”的美称，至今The Cure乐队正式出版发行了近20张专 SMITH,一个来自CRAWLEY的男孩.如今已卖出了两千四百万张唱片,而且是一个只需要在MTV上剪短头发,就能让许多人感到痛苦的男人.他吧他个人的一切都神秘的隐藏在他那引人注意的蜘蛛网般的黑发和血红的嘴唇后面.而对于听过他的音乐的人来说,不管是一直用他的歌声伴随着你的人声,还是偶尔走过他的道路,你都会感受到一个魔幻般的世界.缀满星辰的天空,深蓝色的湖面,鲜艳的深吻…..一切都是如此的不可思议. 在THE CURE二十年的演唱生涯和两千五百万张唱片销量的背后,THE CURE依然是他们遍布全球的歌迷心中的 力量源泉.作为一支非主流音乐的先驱者,他们深深影响了许多后来的乐队,如SMASHING PUMPKINS”和”THE CRADGANS” 等. 就像所有伟大的摇滚乐队一样,THE CURE用音乐在摇滚乐的历史上烙上了他们的印记,成为一代人的代言人. 头发如蜘蛛网般凌乱，熊猫般的黑眼圈，血红的嘴唇，希奇古怪、宽松不合身的衣服，一双奇大无比的运动鞋。害怕毛茸茸的大蜘蛛。恐飞症。幽闭恐怖症。喜好杯中物。超级夜猫子。在一大群乐迷面前会紧张地咬指甲。有时爱滔滔不绝地说话。每出一张专辑都说是最后的、最好的一张，每次巡演都宣称是最后一次。对各式采访者说不同版本的、富于幽默感的故事。讨厌改变，又害怕一成不变。乐队中最聪明和最富才华的人当属Robert Smith。他从未上过艺术学校。他是个天生的音乐家。他用异常敏锐的触觉感受人生，探索人性的最隐秘的角落，然后用独特的、尽善尽美的音乐手法，以最真诚的方式表现出来。The Cure的每一首歌细腻清楚地反映了Robert在不同时期对事物的理解和感受、他的心境和精神状况，就象日记那样真实。他写的诗句既浅显易懂又带有英式的儒雅气质，不象Nirvana的歌词那么口语化，也不象Smashing Pumpkins的某些歌词般具有莎士比亚式的古英语的文绉绉。他喜欢在情绪起伏不平的时候创作，尤其是忧郁、伤感、压抑、悲愤的时候。很多歌都是躺在床上发呆、在花园里散步、喝醉酒、在沙滩上呆望大海、或漫步雨中的时候写成，只有Lullaby和Lovesong两首歌是在桌子前正儿八经地坐下来写的。他演唱的嗓音很特别，象变声期前的男孩的嗓音，象绷得紧紧的橡皮筋，有点病态和神经质，就如凯瑟琳和希思克里夫之间的爱情般奇特、扭曲、痛苦、热烈、激情。他的创作灵感有不少来自于书本，不同时期不同的人去采访他会发现他在读不同的书。他热衷于诗歌、跟哲学和心理学有关的书籍，而谈起《爱丽丝漫游奇镜》和《彼得·潘》来又津津有味。他总是害怕变老，不是担心岁月在身体上留痕，而是害怕会象许多成年人一样，永远失去童真，不再对任何事物好奇，不再为任何事情激动、兴奋，不能做自己想做的事情。事实上他的心态一直都可贵地保持年轻，有时他会觉得有些年纪轻轻的人比他老得多。他还是个很棒的uncle，他有廿多个侄和外甥，他常常带他们去迪斯尼乐园玩、带他们做一些有趣而又刺激的事，甚至接送他们上、下学，他们全都喜欢这个疯疯癫癫的、大孩子似的uncle，愿意跟他分享青春的快乐。”如果是父母的身份又不同了，要承担那么多责任，” Robert和Mary还没有自己的孩子，也许Mary觉得Robert就是个孩子吧。他们俩这么多年的忠贞不渝的专一爱情，一直是乐迷们津津乐道的话题。Mary给了Robert无可比拟的幸福(真值得Courtney Love学习)，这从WISH和WILD MOOD SWINGS可以看得出来。Robert和The Cure一起成熟了，象香醇的美酒。 在世界各地有众多的乐迷对The Cure和Robert Smith程度不一地迷恋献给The Cure的网站和网上俱乐部。在这个以The Cure为核心的虚拟世界里，你可以找到The Cure的传记、专访文章、唱片目录、录象目录、歌词、吉他谱、照片、专辑评论、现场音乐会回顾、各种流言、MiDi和Mp3音乐、唱片交换、电子明信片、自由论坛聊天室…让人流连忘返的Cure世界！ LovesongThe Cure - Greatest Hits CD1 歌曲推荐：the last day of summer、lovesong、to the sky、Sugar girl、Lullaby","link":"/2021/04/27/The%20Cure/"},{"title":"express学习笔记","text":"安装1234$ mkdir myapp$ cd myapp$ npm init$ npm install express --save 全局安装express-generator1npm install express-generator --save -g Hello world example12345678910111213141516171819const express = require('express')const app = express()const port = 3000// 定制 404 页面app.use(function(req, res) { res.type(&quot;text/plain&quot;); res.status(404); res.send(&quot;404 - Not Found&quot;);});// 定制 500 页面app.use(function(err, req, res, next) { console.error(err.stack); res.type(&quot;text/plain&quot;); res.status(500); res.send(&quot;500 - Server Error&quot;);});app.get('/', (req, res) =&gt; res.send('Hello World!'))app.listen(port, () =&gt; console.log(`Example app listening on port ${port}!`))// app.use 是 Express 添加中间件的一种方法 初始化项目1$ express --view=Jade myapp Express 支持多种不同的视图引擎，它们有不同层次的抽象。 支持 (ejs|hbs|hjs|jade|pug|twig|vash) （默认是 jade 模板引擎） 请求报头发送到服务器的并不只是 URL,会发送“用户代理”信息（浏览器、操作系统和硬件设备）和其他一些信息。所有能够确保你了解请求对象头文件属性的信息都将会作为请求报头发送。如果想查看浏览器发送的信息，可以创建一个非常简单的 Express 路由 来展示一下： 12345678app.get(&quot;/headers&quot;, function(req, res) { res.set(&quot;Content-Type&quot;, &quot;text/plain&quot;); var s = &quot;&quot;; for (var name in req.headers) { s += name + &quot;: &quot; + req.headers[name] + &quot;\\n&quot;; } res.send(s);}); 响应报头响应报头还经常会包含一些关于服务器的信息，一般会指出服务器的类型，有时甚至会包含操作系统的详细信息。返回服务器信息存在一个问题，那就是它会给黑客一个可乘之机，从而使站点陷入危险。非常重视安全的服务器经常忽略此信息，甚至提供虚假信息。禁用 Express 的 X-Powered-By 头信息 1app.disable(&quot;x-powered-by&quot;); 请求体除请求报头外，请求还有一个主体（就像作为实际内容返回的响应主体一样） 一般 GET 请求没有主体内 POST 请求体最常见的媒体类型是 application/x-www-form-urlendcoded,是键值对集合的简单编码，用 &amp; 分隔（基本上和查询字符串的格式一样） POST 请求需要支持文件上传，则媒体类型是 multipart/form-data ，它是一种更为复杂的格式 AJAX 请求，它可以使用 application/json请求对象 方法 说明 req.params 一个数组，包含命名过的路由参数 req.param(name) 返回命名的路由参数，或者 GET 请求或 POST 请求参数 req.query 一个对象，包含以键值对存放的查询字符串参数（通常称为 GET 请求参数） req.body 一个对象，包含 POST 请求参数,需要中间件能够解析请求正文内容类型 req.route 关于当前匹配路由的信息。主要用于路由调试 req.cookies/req.singnedCookies 一个对象，包含从客户端传递过来的 cookies 值 req.headers 从客户端接收到的请求报头。 req.accepts([types]) 用来确定客户端是否接受一个或一组指定的类型（可选类型可以是单个的 MIME 类型，如 application/json 、一个逗号分隔集合或是一个数组） req.ip 客户端的 IP 地址。 req.path 请求路径（不包含协议、主机、端口或查询字符串） req.host 一个简便的方法，用来返回客户端所报告的主机名。这些信息可以伪造，所以不应该用于安全目的 req.xhr 一个简便属性，如果请求由 Ajax 发起将会返回 true req.protocol 用于标识请求的协议（ http 或 https ） req.secure 一个简便属性，如果连接是安全的，将返回 true 。等同于 req.protocol===’https’ req.url/req.originalUrl 这些属性返回了路径和查询字符串（它们不包含协议、主机或端口） req.acceptedLanguages 用来返回客户端首选的一组（人类的）语言。这些信息是从请求报头中解析而来的 响应对象|方法|说明||:—-|:—-|:—-||res.status(code)|设置 HTTP 状态代码。Express 默认为 200（成功） res.set(name,value) 设置响应头。这通常不需要手动设置||res.clearCookie(name,[options])|设置或清除客户端 cookies 值。需要中间件支持 res.redirect([status],url) 重定向浏览器。默认重定向代码是 302（建立）||res.send(body)|res.send(status,body) 向客户端发送响应及可选的状态码。Express 的默认内容类型是 text/html||res.json(json)|res.json(status,json) 向客户端发送 JSON 以及可选的状态码| 内容渲染渲染内容用 res.render ，如果想写一个快速测试页，也许会用到 res.send req.query 得到查询字符串的值，使用 req.session 得到会话值，或使用 req.cookie/req.singedCookies 得到 cookies 值 123app.get(&quot;/about&quot;, function(req, res) { res.render(&quot;about&quot;);}); 200以外响应代码12345678app.get(&quot;/error&quot;, function(req, res) { res.status(500); res.render(&quot;error&quot;);});//或者是一行代码app.get(&quot;/error&quot;, function(req, res) { res.status(500).render(&quot;error&quot;);}); 将上下文传递给视图，包括查询字符串12345678app.get(&quot;/greeting&quot;, function(req, res) { res.render(&quot;about&quot;, { message: &quot;welcome&quot;, style: req.query.style, userid: req.cookie.userid, username: req.session.username });}); 使用定制布局渲染视图123app.get(&quot;/custom-layout&quot;, function(req, res) { res.render(&quot;custom-layout&quot;, { layout: &quot;custom&quot; });}); 添加错误处理程序1234app.use(function(err, req, res, next) { console.error(err.stack); res.status(500).render(&quot;error&quot;);}); 添加一个 404 处理程序123app.use(function(req, res) { res.status(404).render(&quot;not-found&quot;);}); 基本表单处理表单信息一般在 req.body 中（或者偶尔在 req.query 中）。你可以使用 req.xhr 来判断是 AJAX 请求还是浏览请求 12345678// 必须引入中间件 body-parserapp.post(&quot;/process-contact&quot;, function(req, res) { console.log( &quot;Received contact from &quot; + req.body.name + &quot; &lt;&quot; + req.body.email + &quot;&gt;&quot; ); // 保存到数据库…… res.redirect(303, &quot;/thank-you&quot;);}); 路由路径和正则表达式路由中指定的路径（比如 /foo）最终会被 Express 转换成一个正则表达式。某些正则表达式中的元字符可以用在路由路径中： + 、 ? 、 * 、 ( 和 ) 。我们看两个例子。比如你想用同一 个路由处理 /user 和 /username 两个 URL： 123app.get(&quot;/user(name)?&quot;, function(req, res) {res.render(&quot;user&quot;);});","link":"/2021/04/27/express%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"typeScript学习笔记","text":"js 缺什么 类型检查 语言扩展 vscode 补全 重塑类型思维。 强类型，弱类型语言。 java C# 等传统高级语言看 js： 面向对象，继承，多态，接口，命名空间，变量修饰，构造函数，访问器get set 静态属性 委托 泛型(随意的类型) 反射（看包内的数组，动态分析东西是什么） 集合 数据结构高级动态语言。 动态数组ArrayList Hashtable SortedList Stack Queue 匿名方法 拆箱 多线程 workerts 入门 搭建 TS 运行环境安装TypeScript有两种主要的方式来获取TypeScript工具： 通过npm（Node.js包管理器） 安装Visual Studio的TypeScript插件 Visual Studio 2017和Visual Studio 2015 Update 3默认包含了TypeScript。 如果你的Visual Studio还没有安装TypeScript，你可以下载它。 针对使用npm的用户： 1&gt; npm install -g typescript 基本类型 枚举把一组数值 变为 有意义的名字。 用途：抽离常量，单独维护，节省记忆成本 接口 Interface实现对对象的类型定义，不会编译，再开发阶段起辅助作用。 函数类型的接口 类也包含了 继承 抽象 接口 setter getter等。 类里的属性方法默认是 public。也可以被设置成 private protected 类和接口的关系 混合使用 类型断言会自动进行推断，从右到左。 上下文类型推断。","link":"/2021/04/27/typeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"大文件分片上传简易版","text":"一、FileReader()读取文件1、描述FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用File或Blob对象指定要读取的文件或数据。 其中File对象可以是来自用户在一个&lt;input&gt;元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。 2、属性 FileReader.error 表示在读取文件时发生的错误 FileReader.readyState FilerReader.result 读取到的结果3、事件处理 FileReader.onabort 处理abort事件。该事件在读取操作被中断时触发。 FileReader.onerror 处理error事件。该事件在读取操作发生错误时触发。 FileReader.onload 处理load事件。该事件在读取操作完成时触发。 FileReader.onloadstart 处理loadstart事件。该事件在读取操作开始时触发。 FileReader.onloadend 处理loadend事件。该事件在读取操作结束时（要么成功，要么失败）触发。 FileReader.onprogress 处理progress事件。该事件在读取Blob时触发。 4、方法FileReader.abort() 中止读取操作。在返回时，readyState属性为DONE。 FileReader.readAsArrayBuffer() 开始读取指定的Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的ArrayBuffer数据对象. FileReader.readAsBinaryString() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。 FileReader.readAsDataURL() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data:URL格式的Base64字符串以表示所读取文件的内容。 FileReader.readAsText() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。 二、切片原理1、利用slice对ArrayBuffer数据对象或者直接对file[0]进行循环切割 2、同时并发请求上传n个切片 3、切片上传完成后，请求合并","link":"/2021/04/27/%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E7%AE%80%E6%98%93%E7%89%88/"},{"title":"typescript进阶之重难点梳理","text":"一、可索引类型「ts 的核心原则之一就是对值所具有的结构进行类型检查。」它有时被称之为“鸭式辩型法”或“结构性子类型”。而接口就是其中的契约。可索引类型也是接口的一种表现形式。 StringArray接口，它具有索引签名。 这个索引签名表示了当用number去索引StringArray时会得到string类型的返回值。 Typescript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。 name的类型与字符串索引类型不匹配 也可以将索引签名设置为只读，这样就可以防止给索引赋值 二、interface 和 type 关键字interface和type两个关键字的含义和功能都非常的接近。这里罗列下这两个主要的区别： interface： 同名的interface自动聚合，也可以跟同名的class自动聚合 只能表示object、class、function类型 type: 不仅仅能够表示object、class、function 不能重名（自然不存在同名聚合了），扩展已有的type需要创建新type 支持复杂的类型操作1、Objects/Functions 2、其他数据类型与interface不同，type还可以用来标书其他的类型，比如基本数据类型、元素、并集等 3、Extend「interface 和 type 彼此并不互斥」。 interface extends interface12interface PartialPointX {x:number;};interface Point extends PartialPointX {y:number;}; type extends type12type PartialPointX = {x:number;};type Point = PartialPointX &amp; {y:number;}; interface extends type12type PartialPointX = {x:number;};interface Point extends PartialPointX {y:number;}; type extends interface12interface ParticalPointX = {x:number;};type Point = ParticalPointX &amp; {y:number}; 4、implement一个类，可以以完全相同的形式去实现interface或者type。但是，类和接口都被视为静态蓝图（static blueprints），因此，他们不能实现/继承 联合类型的type 12345678910111213141516171819202122interface Point { x: number; y: number;}class SomePoint implements Point { x: 1; y: 2;}type Point2 = { x: number; y: number;};class SomePoint2 implements Point2 { x: 1; y: 2;}type PartialPoint = { x: number; } | { y: number; };// FIXME: can not implement a union typeclass SomePartialPoint implements PartialPoint { x: 1; y: 2;} 5、声明合并和type不同，interface可以被重复定义，并且会被自动聚合 123interface Point {x:number;};interface Point {y:number;};const point:Pint = {x:1,y:2}; 6、only interface can在实际开发中，有的时候也会遇到interface能够表达，但是type做不到的情况：「给函数挂载属性」 123456789interface FuncWithAttachment { (param: string): boolean; someProperty: number;}const testFunc: FuncWithAttachment = function(param: string) { return param.indexOf(&quot;Neal&quot;) &gt; -1;};const result = testFunc(&quot;Nealyang&quot;); // 有类型提醒testFunc.someProperty = 4; 三、泛型泛型就是指定一个表示类型的变量，用它来代替某个实际的类型用于编程，而后再通过实际运行或推导的类型来对其进行替换，以达到一段使用泛型程序可以实际适应不同类型的目的。说白了，「泛型就是不预先确定的数据类型，具体的类型在使用的时候再确定的一种类型约束规范」。 泛型可以应用于function、interface、type或者class中。但是注意，「泛型不能应用于类的静态成员」 12345678function log&lt;T&gt;(value: T): T { console.log(value); return value;}// 两种调用方式log&lt;string[]&gt;(['a', ',b', 'c'])log(['a', ',b', 'c'])log('Nealyang') 泛型类型、泛型接口1234567type Log = &lt;T&gt;(value: T) =&gt; Tlet myLog: Log = loginterface Log&lt;T&gt; { (value: T): T}let myLog: Log&lt;number&gt; = log // 泛型约束了整个接口，实现的时候必须指定类型。如果不指定类型，就在定义的之后指定一个默认的类型myLog(1) 「也可以把泛型变量理解为函数的参数，只不过是另一个维度的参数，是代表类型而不是代表值的参数。」*12345678910class Log&lt;T&gt; { // 泛型不能应用于类的静态成员 run(value: T) { console.log(value) return value }}let log1 = new Log&lt;number&gt;() //实例化的时候可以显示的传入泛型的类型log1.run(1)let log2 = new Log()log2.run({ a: 1 }) //也可以不传入类型参数，当不指定的时候，value 的值就可以是任意的值 类型约束，需预定义一个接口1234567891011interface Length { length: number}function logAdvance&lt;T extends Length&gt;(value: T): T { console.log(value, value.length); return value;}// 输入的参数不管是什么类型，都必须具有 length 属性logAdvance([1])logAdvance('123')logAdvance({ length: 3 }) 泛型的好处： 函数和类可以轻松的支持多种类型，增强程序的扩展性 不必写多条函数重载，冗长的联合类型声明，增强代码的可读性 灵活控制类型之间的约束四、类型断言 12345678910const nealyang = {};nealyang.enName = 'Nealyang'; // Error: 'enName' 属性不存在于 ‘{}’nealyang.cnName = '一凨'; // Error: 'cnName' 属性不存在于 '{}'interface INealyang = { enName:string; cnName：string;}const nealyang = {} as INealyang; // const nealyang = &lt;INealyang&gt;{};nealyang.enName = 'Nealyang';nealyang.cnName = '一凨'; 类型断言比较简单，其实就是“纠正”ts对类型的判断。需要注意一下两点即可： 推荐类型断言的预发使用as关键字，而不是&lt;&gt;,防止歧义 类型断言并非类型转换，类型断言发生在编译阶段。类型转换发生在运行时 五、keyof「keyof 是索引类型操作符」。用于获取一个“常量”的类型,这里的“常量”是指任何可以在编译期确定的东西，例如const、function、class等。 它是从「实际运行代码」通向「类型系统」的单行道。理论上，任何运行时的符号名想要为类型系统所用，都要加上typeof。 在使用class时，class名表示实例类型，typeof class表示class本身类型。是的，这个关键字和 js 的typeof关键字重名了 。 假设 T 是一个类型，那么keyof T产生的类型就是T的属性名称字符串字面量类型构成的联合类型。 123456interface IQZQD{ cnName:string; age:number; author:string;}type ant = keyof IQZQD; 在vscode上，可以看到ts推断出来的ant：注意，如果T是带有字符串索引的类型，那么keyof T是string或者number类型。 索引签名参数类型必须为 “string” 或 “number” 123456interface Map&lt;T&gt; { [key: string]: T;}//T[U]是索引访问操作符;U是一个属性名称。let keys: keyof Map&lt;number&gt;; //string | numberlet value: Map&lt;number&gt;['antzone'];//number 六、extendsextends即为扩展、继承。在 ts 中，「extends 关键字既可以来扩展已有的类型，也可以对类型进行条件限定」。在扩展已有类型时，不可以进行类型冲突的覆盖操作。例如，基类型中键a为string，在扩展出的类型中无法将其改为number。 12345678910type num = { num:number;}interface IStrNum extends num { str:string;}// 与上面等价type TStrNum = A &amp; { str:string;} 在 ts 中，还可以通过条件类型进行一些三目操作：T extends U ? X : Y 123type IsEqualType&lt;A , B&gt; = A extends B ? (B extends A ? true : false) : false;type NumberEqualsToString = IsEqualType&lt;number,string&gt;; // falsetype NumberEqualsToNumber = IsEqualType&lt;number,number&gt;; // true 未完待续……","link":"/2021/04/27/typescript%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%87%8D%E9%9A%BE%E7%82%B9%E6%A2%B3%E7%90%86/"},{"title":"探究Object.defineProperty","text":"一、从零认识Object.defineProperty基本用法及属性Object.defineProperty方法用于在对象上定义一个新属性，或者修改对象现有属性，并返回此对象。注意，请通过Object构造器调用此方法，而不是对象实例。 方法基本语法如下： 1Object.defineProperty(obj, prop, descriptor) 添加属性与修改属性： 123456789// 添加属性let o = {};Object.defineProperty(o, 'name', {value:'echo'});o.name;// 'echo'// 修改现有属性o.age = 27;// 重返18岁Object.defineProperty(o, 'age', {value:18});o.age;// 18 语法中的obj是我们要 添加/修改 属性的对象，prop是我们希望 添加/修改 的属性名，而descriptor是我们添加/修改属性的具体描述，descriptor包含属性较多。 descriptor中的数据描述符对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。存取描述符是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一，不能同时是两者。 descriptor中属性可分为了3类，数据描述符类（value，writable），存取描述符类（get，set），以及能与数据描述符或者存取描述符共存的共有属性（configurable，enumerable）。 writablewritable是一个布尔值，若不定义默认为false，表示此条属性只可读，不可修改 123456789let o = {};Object.defineProperty(o, 'name', { value: '听风是风', writable: false});// 尝试修改name属性o.name = '时间跳跃';// 再次读取，结果并未修改成功o.name;// 听风是风 constconst声明的变量是否可修改，准确来说可以改，分两种情况 1234567891011// 值为基本类型const a = 1;a = 2;// 报错// 值为复杂类型const b = [1];b = [1,2];// 报错const c = [1];c[0] = 0;c;// [0]如果const声明变量赋值是基本类型，只要修改值一定报错；如果值是引用类型，比如值是一个数组，当我们直接使用赋值运算符整个替换数组还是会报错，但如果我们不是整个替换数组而是修改数组中某个元素可以发现并不会报错。 这是因为对于引用数据类型而言，变量保存的是数据存放的引用地址，比如b的例子，原本指向是[1]的地址，后面直接要把地址改成数组[1,2]的地址，这很明显是不允许的，所以报错了。但在c的例子中，我们只是把c地址指向的数组中的一位元素改变了，并未修改地址，这对于const是允许的。这个特性对于writable也是适用的 : 123456789let o = {};Object.defineProperty(o, 'age', { value: [27], writable: false});// 尝试修改name属性o.age[0] = 18;// 再次读取，修改成功o.age; // 18 descriptor中的存取描述符存取描述符，也就是在vue中也出现过getter、setter方法 JavaScript中对象赋值与取值非常方便，有如下两种方式： 12345let o = {};// 通过.赋值取值o.name = 'echo';//通过[]赋值取值，这种常用于key为变量情况o['age'] = 27; 存取描述符给了我们赋值/取值时数据劫持的机会，也就就是在赋值与取值时能自定义做一些操作getter函数在获取属性值时触发，注意，是你为某个属性添加了getter在获取这个属性才会触发，如果未定义则为undefined，该函数的返回值将作为你访问的属性值。 setter函数在设置属性时触发，同理你得为这个属性提前定义这个方法才行，设置的值将作为参数传入到setter函数中，在这里我们可以加工数据，若未定义此方法默认也是undefined。 getter与setter模拟一个最常见的对象赋值与取值例子： 1234567891011121314151617let o = {};o.name = '听风是风';o.name; // '听风是风'//使用get set模拟赋值取值操作let age;Object.defineProperty(o, 'age', { get() { // 直接返回age return age; }, set(val) { // 赋值时触发，将值赋予变量age age = val; }});o.age = 18;o.age; // 18 descriptor中的共有属性enumerableenumerable值类型为Boolean，表示该属性是否可被枚举，Object.keys()用于获取对象可枚举属性 如果我们设置enumerable为false时： 123456789101112131415let o = { name: '听风是风'};Object.defineProperty(o, 'age', { value: 27, enumerable: false});// 无法获取keysObject.keys(o); // ['name']// 无法遍历访问for (let i in o) { console.log(i); // 'name'}; configurableconfigurable的值也是Boolean，默认是false，configurable 特性表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。 删除： 1234567891011let o = { name: '听风是风'};Object.defineProperty(o, 'age', { value: 27, configurable: false});delete o.name;//truedelete o.age;//falseo.name;//undefinedo.age;//18 其它属性的影响： 1234567891011121314151617181920212223242526272829var o = {};Object.defineProperty(o, 'name', { get() { return '听风是风'; }, configurable: false});// 报错，尝试通过再配置修改name的configurable失败，因为已经定义过了configurableObject.defineProperty(o, 'name', { configurable: true});//报错，尝试修改name的enumerable为true，失败，因为未定义默认为falseObject.defineProperty(o, 'name', { enumerable: true});//报错，尝试新增set函数，失败，一开始没定义set默认为undefinedObject.defineProperty(o, 'name', { set() {}});//尝试再定义get，报错，已经定义过了Object.defineProperty(o, 'name', { get() { return 1; }});// 尝试添加数据描述符中的vaule，报错，数据描述符无法与存取描述符共存Object.defineProperty(o, 'name', { value: 12}); 当configurable为false时，这些属性都无法被重新定义以及修改。 其它注意点1、对象属性描述符要么是数据描述符（value，writable），要么是存取描述符（get，set），不应该同时存在两者描述符。 123456789var o = {};Object.defineProperty(o, 'name', { value: '时间跳跃', get() { return '听风是风'; }});这个例子就会报错，其实不难理解，存取方法就是用来定义属性值的，value也是用来定义值的，同时定义程序也不知道该以哪个为准了，所以用了value/writable其一，就不能用get/set了；不过configurable与enumerable这两个属性可以与上面两种属性任意搭配。 各个属性是有默认值的，所以在用Object.defineProperty()时某个属性没定义不是代表没用这条属性，而是会用这条属性的默认值。 1234567891011let o = {};Object.defineProperty(o, 'name', { value: '时间跳跃'});//等同于Object.defineProperty(o, 'name', { value: '时间跳跃', writable: false, enumerable: false, configurable: false}); 123456789101112131415161718192021var o = {};o.name = '听风是风';//等同于Object.defineProperty(o, 'name', { value: '听风是风', writable: true, enumerable: true, configurable: true});//等同于let name = '听风是风';Object.defineProperty(o, 'name', { get() { return name; }, set(val) { name = val; }, enumerable: true, configurable: true}); 2、属性分类与默认值|configurable|enumerable|value|writable|get|set| ||:—-|:—-|:—-|:—-|:—-|:—-|:—-|:—-|:—-|:—-|:—-|:—-|:—-|:—-||数据描述符|可以|可以|可以|可以|不可以|不可以||存取描述符|可以|可以|不可以|不可以|可以|可以||默认值|false|false|false|false|undefined|undefined|","link":"/2021/04/26/%E6%8E%A2%E7%A9%B6Object-defineProperty/"},{"title":"生成应用脚手架学习","text":"一、基础学习 开发node cli脚手架流程1、 初始化 npm init -y 创建package.json修改package.json加入常用依赖包 自动初始化一个项目的流程主要是以下三点： 读取用户配置 读取模板文件 根据配置，编译模板文件，输出最终文件 所需常用依赖： （1）配置信息工具commander一个帮助快速开发Nodejs命令行工具的package version 定义版本号 1234567891011121314var program = require('commander'); program .version('0.0.1') .parse(process.argv); //添加参数解析#执行结果：node index.js -V 0.0.1#如果希望程序响应-v选项而不是-V选项，#只需使用与option方法相同的语法将自定义标志传递给version方法program .version('0.0.1', '-v, --version') option 使用**.option()方法定义commander的选项options** 示例：.option(‘-n, –name [items2]’, ‘name description’, ‘default value’) 参数解析： 自定义标志&lt;必须&gt;：分为长短标识，中间用逗号、竖线或者空格分割；标志后面可跟必须参数或可选参数，前者用&lt;&gt;包含，后者用[]包含 选项描述&lt;省略不报错&gt;：在使用 –help 命令时显示标志描述 默认值&lt;可省略&gt; 短标志可以作为单独的参数传递。像 -abc 等于 -a -b -c。多词组成的选项，像“–template-engine”会变成 program.templateEngine 等。 command 作用：添加命令名称 示例：.command('add &lt;num&gt;[otherDirs...]', 'install description', opts) 参数解析： 命令名称&lt;必须&gt;：命令后面可跟用 &lt;&gt; 或 [] 包含的参数；命令的最后一个参数可以是可变的，像实例中那样在数组后面加入 … 标志；在命令后面传入的参数会被传入到 action 的回调函数以及 program.args 数组中 命令描述&lt;可省略&gt;：如果存在，且没有显示调用action(fn)，就会启动子命令程序，否则会报错 配置选项&lt;可省略&gt;：可配置noHelp、isDefault等 alias description usage 定义命令的别名 描述和用法 1234567891011.alias('r').usage('[options] &lt;file ...&gt;').description('run setup commands for all envs')#outputgp-cli rm --helpUsage: rm|r [options] &lt;file ...&gt;run setup commands for all envsOptions: -r, --recursive Remove recursively -d --drink [drink] Drink -h, --help output usage information inquirerinquirer为NodeJs做一个可嵌入式的美观的命令行界面 Inquirer.js仅仅给用户提供了一个漂亮的界面和提出问题流的方式。 它是非常容易去处理以下几种事情的： 提供错误回调 询问操作者问题 获取并解析用户输入 检测用户回答是否合法 管理多层级的提示 inquirer为每个问题提供很多参数： 1234567891011{ type: String, // 表示提问的类型，下文会单独解释 name: String, // 在最后获取到的answers回答对象中，作为当前这个问题的键 message: String|Function, // 打印出来的问题标题，如果为函数的话 default: String|Number|Array|Function, // 用户不输入回答时，问题的默认值。或者使用函数来return一个默认值。假如为函数时，函数第一个参数为当前问题的输入答案。 choices: Array|Function, // 给出一个选择的列表，假如是一个函数的话，第一个参数为当前问题的输入答案。为数组时，数组的每个元素可以为基本类型中的值。 validate: Function, // 接受用户输入，并且当值合法时，函数返回true。当函数返回false时，一个默认的错误信息会被提供给用户。 filter: Function, // 接受用户输入并且将值转化后返回填充入最后的answers对象内。 when: Function|Boolean, // 接受当前用户输入的answers对象，并且通过返回true或者false来决定是否当前的问题应该去问。也可以是简单类型的值。 pageSize: Number, // 改变渲染list,rawlist,expand或者checkbox时的行数的长度。} 语法结构 1234567const inquirer = require('inquirer');const promptList = [ // 具体交互内容];inquirer.prompt(promptList).then(answers =&gt; { console.log(answers); // 返回的结果}) input 12345678910111213141516const promptList = [{ type: 'input', message: '设置一个用户名:', name: 'name', default: &quot;test_user&quot; // 默认值},{ type: 'input', message: '请输入手机号:', name: 'phone', validate: function(val) { if(val.match(/\\d{11}/g)) { // 校验位数 return val; } return &quot;请输入11位数字&quot;; }}]; 效果： comfirm 1234567891011121314const promptList = [{ type: &quot;confirm&quot;, message: &quot;是否使用监听？&quot;, name: &quot;watch&quot;, prefix: &quot;前缀&quot;},{ type: &quot;confirm&quot;, message: &quot;是否进行文件过滤？&quot;, name: &quot;filter&quot;, suffix: &quot;后缀&quot;, when: function(answers) { // 当watch为true的时候才会提问当前问题 return answers.watch }}]; 效果： list 12345678910111213const promptList = [{ type: 'list', message: '请选择一种水果:', name: 'fruit', choices: [ &quot;Apple&quot;, &quot;Pear&quot;, &quot;Banana&quot; ], filter: function (val) { // 使用filter将回答变为小写 return val.toLowerCase(); }}]; 效果： expand 12345678910111213141516171819202122const promptList = [{ type: &quot;expand&quot;, message: &quot;请选择一种水果：&quot;, name: &quot;fruit&quot;, choices: [ { key: &quot;a&quot;, name: &quot;Apple&quot;, value: &quot;apple&quot; }, { key: &quot;O&quot;, name: &quot;Orange&quot;, value: &quot;orange&quot; }, { key: &quot;p&quot;, name: &quot;Pear&quot;, value: &quot;pear&quot; } ]}]; 效果： password 12345const promptList = [{ type: &quot;password&quot;, // 密码为密文输入 message: &quot;请输入密码：&quot;, name: &quot;pwd&quot;}]; 效果： editor 12345const promptList = [{ type: &quot;editor&quot;, message: &quot;请输入备注：&quot;, name: &quot;editor&quot;}]; 效果： （2）模板信息工具mem-fs &amp; mem-fs-editormem-fs &amp; mem-fs-editor提供了一系列API，方便操作模板文件。mem-fs是对文件进行读取，存入内存中 读写文件 **read(filepath, [options])**：将文件内容作为string返回。options.raw = true可以返回文件原始内容buffer。文件不存在会报错，如果你不想用try-catch，可以设置options.defaults返回默认值，这样就不会报错了。 **readJSON(filepath, [defaults])**：读JSON **write(filepath, contents)**：写文件 **writeJSON(filepath, contents[, replacer [, space]])**：写JSON 123456789101112131415const path = require('path');const memFs = require(&quot;mem-fs&quot;);const editor = require(&quot;mem-fs-editor&quot;);const store = memFs.create();const fs = editor.create(store);const srcFile = path.resolve(__dirname, '../tmp/data2.txt');const srcJson = path.resolve(__dirname, '../../package.json');const destTpl = path.resolve(__dirname, '../tmp/dataMemFs.tpl');const destJson = path.resolve(__dirname, '../tmp/dataMemFs.json');fs.read(srcFile); // hello world!fs.read(srcFile, { raw: true }); // &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64 21&gt;fs.read('somefile.txt', { defaults: '文件不存在' }); // 文件不存在fs.readJSON(srcJson); // json对象fs.write(destTpl, &quot;&lt;%= value %%gt;&quot;);fs.writeJSON(destJson, JSON.parse(JSON.stringify({ name: &quot;tool-demo&quot; }))); 改删文件 **append(filepath, contents, [options])**：文件末添加新内容，options.trimEnd默认为true，options.separator新旧内容间的分隔符，默认EOL **extendJSON(filepath, contents[, replacer [, space]])**：JSON文件末添加新内容 **delete(filepath, [options])**：删文件或文件夹 123fs.append(destTpl, &quot;&lt;%= value2 %&gt;&quot;, { separator: '\\r\\n----\\r\\n' });fs.extendJSON(destJson, JSON.parse(JSON.stringify({ description: &quot;some tool demo&quot; })));fs.delete(destJson); 拷贝、移动文件 **copy(from, to, [options], context[, templateOptions ])**：拷贝文件 **copyTpl(from, to, context[, templateOptions [, copyOptions]])**：拷贝模板 **move(from, to, [options])**：移动文件 123456fs.copy(destTpl, path.join(__dirname, '../tmp/mem-fs/dataMemFs.tpl'));fs.copyTpl(destTpl, path.join(__dirname, '../tmp/mem-fs/dataMemFs.txt'), { value: 1, value2: 2});fs.move(path.join(__dirname, '../tmp/mem-fs/dataMemFs.tpl'), destTpl); 其他 **exists(filepath)**：文件是否存在 **commit([filters,] callback)**：将内存中的文件操作全部提交到磁盘上 123fs.exists(destTpl); // truefs.commit(() =&gt; {}); // 同步fs.commit(() =&gt; { resolve(); }); // 异步 （3）提示信息工具chalkchalk包的作用是修改控制台中字符串的样式，包括： 字体样式(加粗、隐藏等) 字体颜色 背景颜色 chalk支持两种方式使用：常规的调用方式和模板中使用的方式。 常规使用 模板使用（4）文件操作 fs-extradownload-git-repo2、新建src文件夹，表示脚手架的源文件，创建入口main.js3、 新建bin文件夹/www文件，表示使用那个核心文件4、 映射命令行工具，配置指令能被node识别5、 打印帮助6、 配置几个常用的指令7、 逻辑编写二、best-cli解析","link":"/2021/04/27/%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%AD%A6%E4%B9%A0/"},{"title":"qiankun","text":"一、qiankun与single-spa实现原理qiankun是基于single-spa 一般来说，微前端需要解决的问题分为两大类： 应用的加载与切换 应用的隔离与通信 应用的加载与切换需要解决的问题包括：路由问题、应用入口、应用加载； 应用的隔离与通信需要解决的问题包括：js隔离、css样式隔离、应用间通信。 single-spa很好地解决了路由和应用入口两个问题，但并没有解决应用加载问题，而是将该问题暴露出来由使用者实现（一般可以用system.js或原生script标签来实现）；qiankun在此基础上封装了一个应用加载方案（即import-html-entry），并给出了js隔离、css样式隔离和应用间通信三个问题的解决方案，同时提供了预加载功能。 借助single-spa提供的能力，我们只能把不同的应用加载到一个页面内，但是很难保证这些应用不会互相干扰。而qiankun解决了这些问题，使得它成为一个更加完整的微前端运行时容器。 1、single-spa实现原理（1）基础概念 加载器：也就是微前端架构的核心，主要用来调度子应用，决定何时展示哪个子应用， 可以把它理解成电源。 包装器：有了加载器，可以把现有的应用包装，使得加载器可以使用它们，它相当于电源适配器。 主应用：一般是包含所有子应用公共部分的项目—— 它相当于电器底座 子应用：众多展示在主应用内容区的应用—— 它相当于你要使用的电器，所以是这么个概念：电源(加载器)→电源适配器(包装器)→️电器底座(主应用)→️电器(子应用)️ 总的来说是这样一个流程：用户访问index.html后，浏览器运行加载器的js文件，加载器去配置文件，然后注册配置文件中配置的各个子应用后，首先加载主应用(菜单等)，再通过路由判定，动态远程加载子应用。 SystemJS一个运行于浏览器端的模块加载器，提供通用的模块导入途径，支持传统模块和ES6的模块。 SystemJs有两个版本，6.x版本是在浏览器中使用的，0.21版本的是在浏览器和node环境中使用的，两者的使用方式不同。(参考：https://github.com/systemjs/systemjs) 在微服务中相当于加载器的角色。 singleSpa single-spa是一个在前端应用程序中将多个javascript应用集合在一起的框架。相当于包装器的角色 （2）路由问题single-spa是通过监听hashChange和popState这两个原生事件来检测路由变化的，它会根据路由的变化来加载对应的应用。 相关的代码可以在single-spa的src/navigation/navigation-events.js中找到： 12345678910111213141516...// 139行if (isInBrowser) { // We will trigger an app change for any routing events. window.addEventListener(&quot;hashchange&quot;, urlReroute); window.addEventListener(&quot;popstate&quot;, urlReroute);...// 174行，劫持pushState和replaceState window.history.pushState = patchedUpdateState( window.history.pushState, &quot;pushState&quot; ); window.history.replaceState = patchedUpdateState( window.history.replaceState, &quot;replaceState&quot; ); single-spa在检测到发生hashChange或popState事件时，会执行urlReroute函数，这里封装了它对路由问题的解决方案。另外，它还劫持了原生的pushState和replaceState事件 urlReroute： 123function urlReroute() { reroute([], arguments);} reroute函数就是single-spa解决路由问题的核心逻辑 1234567891011121314151617181920212223242526272829303132333435363738export function reroute(pendingPromises = [], eventArguments) { ... // getAppChanges会根据路由改变应用的状态，状态包含4类 // 待清除、待卸载、待加载、待挂载 const { appsToUnload, appsToUnmount, appsToLoad, appsToMount, } = getAppChanges(); ... // 如果应用已启动，则调用performAppChanges加载和挂载应用 // 否则，只加载未加载的应用 if (isStarted()) { appChangeUnderway = true; appsThatChanged = appsToUnload.concat( appsToLoad, appsToUnmount, appsToMount ); return performAppChanges(); } else { appsThatChanged = appsToLoad; return loadApps(); } ... function performAppChanges() { return Promise.resolve().then(() =&gt; { // 1. 派发应用更新前的自定义事件 // 2. 执行应用暴露出的生命周期函数 // appsToUnload -&gt; unload生命周期钩子 // appsToLoad -&gt; 执行加载方法 // appsToUnmount -&gt; 卸载应用，并执行对应生命周期钩子 // appsToMount -&gt; 尝试引导和挂载应用 }) } ...} single-spa解决路由问题的主要逻辑 根据传入的参数activeWhen判断哪个应用需要加载，哪个应用需要卸载或清除，并将其push到对应的数组 如果应用已经启动，则进行应用加载或切换。针对应用的不同状态，直接执行应用自身暴露出的生命周期钩子函数即可。 如果应用未启动，则只去下载appsToLoad中的应用。 总的来看，当路由发生变化时，hashChange或popState会触发，这时single-spa会监听到，并触发urlReroute；接着它会调用reroute，该函数正确设置各个应用的状态后，直接通过调用应用所暴露出的生命周期钩子函数即可。当某个应用被推送到appsToMount后，它的mount函数会被调用，该应用就会被挂载；而推送到appsToUnmount中的应用则会调用其unmount钩子进行卸载。 （3）应用入口single-spa采用的是协议入口，即只要实现了single-spa的入口协议规范，它就是可加载的应用。single-spa的规范要求应用入口必须暴露出以下三个生命周期钩子函数，且必须返回Promise，以保证single-spa可以注册回调函数： bootstrap mount unmount bootstrap用于应用引导，基座应用会在子应用挂载前调用它。 mount用于应用挂载，就是一般应用中用于渲染的逻辑，即上述的new Vue语句。我们通常会把它封装到一个函数里，在mount钩子函数中调用。 unmount用于应用卸载，我们可以在这里调用实例的destroy方法手动卸载应用，或清除某些内存占用等。 除了以上三个必须实现的钩子外，single-spa还支持非必须的load、unload、update等，分别用于加载、卸载和更新应用。 （4）应用加载基于system.js如何启动single-spa： 1234567891011121314151617181920212223242526272829&lt;script type=&quot;systemjs-importmap&quot;&gt; { &quot;imports&quot;: { &quot;app1&quot;: &quot;http://localhost:8080/app1.js&quot;, &quot;app2&quot;: &quot;http://localhost:8081/app2.js&quot;, &quot;single-spa&quot;: &quot;https://cdnjs.cloudflare.com/ajax/libs/single-spa/4.3.7/system/single-spa.min.js&quot; } }&lt;/script&gt;... // system.js的相关依赖文件&lt;script&gt;(function(){ // 加载single-spa System.import('single-spa').then((res)=&gt;{ var singleSpa = res; // 注册子应用 singleSpa.registerApplication('app1', () =&gt; System.import('app1'), location =&gt; location.hash.startsWith(`#/app1`); ); singleSpa.registerApplication('app2', () =&gt; System.import('app2'), location =&gt; location.hash.startsWith(`#/app2`); ); // 启动single-spa singleSpa.start(); })})()&lt;/script&gt; 在调用singleSpa.registerApplication注册应用时提供的第二个参数就是加载这个子应用的方法。如果需要加载多个js，可以使用多个System.import连续导入。single-spa会调用这个函数，下载子应用代码并分别调用其bootstrap和mount方法进行引导和挂载。 从这里我们也可以看到single-spa的弊端。首先我们必须手动实现应用加载逻辑，挨个罗列子应用需要加载的资源，这在大型项目里是十分困难的（特别是使用了文件名hash时）；另外它只能以js文件为入口，无法直接以html为入口，这使得嵌入子应用变得很困难，也正因此，single-spa不能直接加载jQuery应用。 single-spa的start方法也很简单： 123456789export function start(opts) { started = true; if (opts &amp;&amp; opts.urlRerouteOnly) { setUrlRerouteOnly(opts.urlRerouteOnly); } if (isInBrowser) { reroute(); }} 先是设置started状态，然后设置我们上面说到的urlRerouteOnly属性，接着调用reroute，开始首次加载子应用。加载完第一个应用后，single-spa就时刻等待着hashChange或popState事件的触发，并执行应用的切换。以上就是single-spa的核心原理，从上面的介绍中不难看出，single-spa只是负责把应用加载到一个页面中，至于应用能否协同工作，是很难保证的。而qiankun所要解决的，就是协同工作的问题。 （5）应用示例简单示例： https://zh-hans.single-spa.js.org/docs/getting-started-overview vue示例： https://github.com/vue-microfrontends 2、qiankun实现原理（1）应用加载single-spa提供的应用加载方案是开放式的。针对上面的几个弊端，qiankun进行了一次封装，给出了一个更完整的应用加载方案，qiankun将其封装成了npm插件import-html-entry。 该方案的主要思路是允许以html文件为应用入口，然后通过一个html解析器从文件中提取js和css依赖，并通过fetch下载依赖，于是在qiankun中你可以这样配置入口： 123456const MicroApps = [{ name: 'app1', entry: 'http://localhost:8080', container: '#app', activeRule: '/app1'}] qiankun会通过import-html-entry请求http://localhost:8080，得到对应的html文件，解析内部的所有script和style标签，依次下载和执行它们，这使得应用加载变得更易用。import-html-entry暴露出的核心接口是importHTML，用于加载html文件，它支持两个参数： url，要加载的文件地址，一般是服务中html的地址 opts，配置参数 url不必多说。opts如果是一个函数，则会替换默认的fetch作为下载文件的方法，此时其返回值应当是Promise；如果是一个对象，那么它最多支持四个属性：fetch、getPublicPath、getDomain、getTemplate，用于替换默认的方法。 截取该函数的主要逻辑： 123456789101112131415161718192021222324252627282930export default function importHTML(url, opts = {}) { ... // 如果已经加载过，则从缓存返回，否则fetch回来并保存到缓存中 return embedHTMLCache[url] || (embedHTMLCache[url] = fetch(url) .then(response =&gt; readResAsString(response, autoDecodeResponse)) .then(html =&gt; { // 对html字符串进行初步处理 const { template, scripts, entry, styles } = processTpl(getTemplate(html), assetPublicPath); // 先将外部样式处理成内联样式 // 然后返回几个核心的脚本及样式处理方法 return getEmbedHTML(template, styles, { fetch }).then(embedHTML =&gt; ({ template: embedHTML, assetPublicPath, getExternalScripts: () =&gt; getExternalScripts(scripts, fetch), getExternalStyleSheets: () =&gt; getExternalStyleSheets(styles, fetch), execScripts: (proxy, strictGlobal, execScriptsHooks = {}) =&gt; { if (!scripts.length) { return Promise.resolve(); } return execScripts(entry, scripts, proxy, { fetch, strictGlobal, beforeExec: execScriptsHooks.beforeExec, afterExec: execScriptsHooks.afterExec, }); }, })); });} 省略的部分主要是一些参数预处理，我们从return语句开始看，具体过程如下： 检查是否有缓存，如果有，直接从缓存中返回 如果没有，则通过fetch下载，并字符串化 调用processTpl进行一次模板解析，主要任务是扫描出外联脚本和外联样式，保存在scripts和styles中 调用getEmbedHTML，将外联样式下载下来，并替换到模板内，使其变成内部样式 返回一个对象，该对象包含处理后的模板，以及getExternalScripts、getExternalStyleSheets、execScripts等几个核心方法。 processTpl主要基于正则表达式对模板字符串进行解析。我们来看getExternalScripts、getExternalStyleSheets、execScripts这三个方法： getExternalStyleSheets 123456789101112export function getExternalStyleSheets(styles, fetch = defaultFetch) { return Promise.all(styles.map(styleLink =&gt; { if (isInlineCode(styleLink)) { // if it is inline style return getInlineCode(styleLink); } else { // external styles return styleCache[styleLink] || (styleCache[styleLink] = fetch(styleLink).then(response =&gt; response.text())); } ));} 遍历styles数组，如果是内联样式，则直接返回；否则判断缓存中是否存在，如果没有，则通过fetch去下载，并进行缓存。getExternalScripts与上述过程类似。 execScripts是实现js隔离的核心方法。 通过调用importHTML方法，qiankun可以直接加载html文件，同时将外联样式处理成内部样式表，并且解析出JavaScript依赖。更重要的是，它获得了一个可以在隔离环境下执行应用脚本的方法execScripts。 （2）js隔离qiankun通过import-html-entry，可以对html入口进行解析，并获得一个可以执行脚本的方法execScripts。qiankun引入该接口后，首先为该应用生成一个window的代理对象，然后将代理对象作为参数传入接口，以保证应用内的js不会对全局window造成影响。由于IE11不支持proxy，所以qiankun通过快照策略来隔离js，缺点是无法支持多实例场景。 我们先来看基于proxy的js隔离是如何实现的。首先看import-html-entry暴露出的接口，截取核心代码: execScripts 12345678910111213141516171819export function execScripts(entry, scripts, proxy = window, opts = {}) { ... // 初始化参数 return getExternalScripts(scripts, fetch, error) .then(scriptsText =&gt; { // 在proxy对象下执行脚本的方法 const geval = (scriptSrc, inlineScript) =&gt; { const rawCode = beforeExec(inlineScript, scriptSrc) || inlineScript; const code = getExecutableScript(scriptSrc, rawCode, proxy, strictGlobal); (0, eval)(code); afterExec(inlineScript, scriptSrc); }; // 执行单个脚本的方法 function exec (scriptSrc, inlineScript, resolve) { ... } // 排期函数，负责逐个执行脚本 function schedule(i, resolvePromise) { ... } // 启动排期函数，执行脚本 return new Promise(resolve =&gt; schedule(0, success || resolve)); });}); 这个函数的关键是定义了三个函数：geval、exec、schedule，其中实现js隔离的是geval函数内调用的getExecutableScript函数。我们看到，在调这个函数时，我们把外部传入的proxy作为参数传入了进去，而它返回的是一串新的脚本字符串，这段新的字符串内的window已经被proxy替代，具体实现逻辑如下： 1234567891011function getExecutableScript(scriptSrc, scriptText, proxy, strictGlobal) { const sourceUrl = isInlineCode(scriptSrc) ? '' : `//# sourceURL=${scriptSrc}\\n`; // 通过这种方式获取全局 window，因为 script 也是在全局作用域下运行的，所以我们通过 window.proxy 绑定时也必须确保绑定到全局 window 上 // 否则在嵌套场景下， window.proxy 设置的是内层应用的 window，而代码其实是在全局作用域运行的，会导致闭包里的 window.proxy 取的是最外层的微应用的 proxy const globalWindow = (0, eval)('window'); globalWindow.proxy = proxy; // TODO 通过 strictGlobal 方式切换切换 with 闭包，待 with 方式坑趟平后再合并 return strictGlobal ? `;(function(window, self, globalThis){with(window){;${scriptText}\\n${sourceUrl}}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);` : `;(function(window, self, globalThis){;${scriptText}\\n${sourceUrl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;} 核心代码就是由两个矩形框起来的部分，它把解析出的scriptText（即脚本字符串）用with(window){}包裹起来，然后把window.proxy作为函数的第一个参数传进来，所以with语法内的window实际上是window.proxy。 这样，当在执行这段代码时，所有类似var name = ‘张三’这样的语句添加的全局变量name，实际上是被挂载到了window.proxy上，而不是真正的全局window上。当应用被卸载时，对应的proxy会被清除，因此不会导致js污染。而当你配置webpack的打包类型为lib时，你得到的接口大概如下： 1var jquery = (function(){})(); 如果你的应用内使用了jquery，那么这个jquery对象就会被挂载到window.proxy上。不过如果你在代码内直接写window.name = ‘张三’来生成全局变量，那么qiankun就无法隔离js污染了。import-html-entry实现了上述能力后，qiankun要做的就很简单了，只需要在加载一个应用时为其初始化一个proxy传递进来即可： proxySandbox.ts 12345678910export default class ProxySandbox implements SandBox { ... constructor(name: string) { ... const proxy = new Proxy(fakeWindow, { set () { ... }, get () { ... } } }} 每次加载一个应用，qiankun就初始化这样一个proxySandbox，传入上述execScripts函数中。在IE下，由于proxy不被支持，并且没有可用的polyfill，所以qiankun退而求其次，采用快照策略实现js隔离。它的大致思路是，在加载应用前，将window上的所有属性保存起来（即拍摄快照）；等应用被卸载时，再恢复window上的所有属性，这样也可以防止全局污染。但是当页面同时存在多个应用实例时，qiankun无法将其隔离开，所以IE下的快照策略无法支持多实例模式。 （3）css隔离目前qiankun主要提供了两种样式隔离方案，一种是基于shadowDom的；另一种则是实验性的，思路类似于Vue中的scoped属性，给每个子应用的根节点添加一个特殊属性，用作对所有css选择器的约束。 开启样式隔离的语法如下： 123456789registerMicroApps({ name: 'app1', ... sandbox: { strictStyleIsolation: true // 实验性方案，scoped方式 // experimentalStyleIsolation: true },}) 当启用strictStyleIsolation时，qiankun将采用shadowDom的方式进行样式隔离，即为子应用的根节点创建一个shadow root。最终整个应用的所有DOM将形成一棵shadow tree。我们知道，shadowDom的特点是，它内部所有节点的样式对树外面的节点无效，因此自然就实现了样式隔离。但是这种方案是存在缺陷的。因为某些UI框架可能会生成一些弹出框直接挂载到document.body下，此时由于脱离了shadow tree，所以它的样式仍然会对全局造成污染。 此外qiankun也在探索类似于scoped属性的样式隔离方案，可以通过experimentalStyleIsolation来开启。这种方案的策略是为子应用的根节点添加一个特定的随机属性，如： 12345&lt;div data-qiankun-asiw732sde id=&quot;__qiankun_microapp_wrapper__&quot; data-name=&quot;module-app1&quot;&gt; 然后为所有样式前面都加上这样的约束： 1234567.app-main { 字体大小：14 px ; }// -&gt;div[data-qiankun-asiw732sde] .app-main { 字体大小：14 px ; } 经过上述替换，这个样式就只能在当前子应用内生效了。虽然该方案已经提出很久了，但仍然是实验性的，因为它不支持@ keyframes，@ font-face，@ import，@ page（即不会被重写）。 （4）应用通信一般来说，微前端中各个应用之前的通信应该是尽量少的，而这依赖于应用的合理拆分。反过来说，如果你发现两个应用间存在极其频繁的通信，那么一般是拆分不合理造成的，这时往往需要将它们合并成一个应用。 当然了，应用间存在少量的通信是难免的。qiankun官方提供了一个简要的方案，思路是基于一个全局的globalState对象。这个对象由基座应用负责创建，内部包含一组用于通信的变量，以及两个分别用于修改变量值和监听变量变化的方法：setGlobalState和onGlobalStateChange。 以下代码用于在基座应用中初始化它： 1234import { initGlobalState, MicroAppStateActions } from 'qiankun';const initialState = {};const actions: MicroAppStateActions = initGlobalState(initialState);export default actions; 这里的actions对象就是我们说的globalState，即全局状态。基座应用可以在加载子应用时通过props将actions传递到子应用内，而子应用通过以下语句即可监听全局状态变化： 123actions.onGlobalStateChange (globalState, oldGlobalState) { ...} 同样的，子应用也可以修改全局状态： 1actions.setGlobalState(...); 此外，基座应用和其他子应用也可以进行这两个操作，从而实现对全局状态的共享，这样各个应用之间就可以通信了。这种方案与Redux和Vuex都有相似之处，只是由于微前端中的通信问题较为简单，所以官方只提供了这样一个精简方案。关于其实现原理这里不再赘述，感兴趣的可以去看一下源码。 二、qiankun应用1、基础概念（1）基于路由配置适用于 route-based 场景。 通过将微应用关联到一些 url 规则的方式，实现当浏览器 url 发生变化时，自动加载相应的微应用的功能。 registerMicroApps(apps, lifeCycles?) 注册应用 参数 apps -****Array- 必选，微应用的一些注册信息 lifeCycles -LifeCycles- 可选，全局的微应用生命周期钩子 类型 RegistrableApp name -string- 必选，微应用的名称，微应用之间必须确保唯一。 entry -string | { scripts?: string[]; styles?: string[]; html?: string }- 必选，微应用的入口。 配置为字符串时，表示微应用的访问地址，例如**https://qiankun.umijs.org/guide/**。 配置为对象时，html的值是微应用的 html 内容字符串，而不是微应用的访问地址。微应用的publicPath将会被设置为**/**。 container -string | HTMLElement- 必选，微应用的容器节点的选择器或者 Element 实例。如**container: ‘#root’或container: document.querySelector(‘#root’)**。 activeRule -string | (location: Location) =&gt; boolean | Array&lt;string | (location: Location) =&gt; boolean&gt;- 必选，微应用的激活规则。 LifeCycles 生命周期 用法 注册微应用的基础配置信息。当浏览器 url 发生变化时，会自动检查每一个微应用注册的activeRule规则，符合规则的应用将会被自动激活。 示例 123456789101112131415161718import { registerMicroApps } from 'qiankun';registerMicroApps( [ { name: 'app1', entry: '//localhost:8080', container: '#container', activeRule: '/react', props: { name: 'kuitos', }, }, ], { beforeLoad: (app) =&gt; console.log('before load', app.name), beforeMount: [(app) =&gt; console.log('before mount', app.name)], },); start(opts?) 用法 启动 qiankun。 示例12import { start } from 'qiankun';start(); (2)手动加载微应用 适用于需要手动 加载/卸载 一个微应用的场景。 通常这种场景下微应用是一个不带路由的可独立运行的业务组件。 微应用不宜拆分过细，建议按照业务域来做拆分。业务关联紧密的功能单元应该做成一个微应用，反之关联不紧密的可以考虑拆分成多个微应用。 一个判断业务关联是否紧密的标准：看这个微应用与其他微应用是否有频繁的通信需求。如果有可能说明这两个微应用本身就是服务于同一个业务场景，合并成一个微应用可能会更合适。 loadMicroApp（app, configuration?）手动加载子应用 参数 app 微应用基础信息 name entry container props(可通过此参数传递主应用数据到子应用，包括vuex、router、全局方法，mixins等数据) configuration 微应用配置信息 sandbox -boolean | { strictStyleIsolation?: boolean, experimentalStyleIsolation?: boolean }- 可选，是否开启沙箱，默认为true。 singular -boolean | ((app: RegistrableApp) =&gt; Promise);- 可选，是否为单实例场景，单实例指的是同一时间只会渲染一个微应用。默认为false。 fetch -Function- 可选，自定义的 fetch 方法。 getPublicPath -(entry: Entry) =&gt; string- 可选，参数是微应用的 entry 值。 getTemplate -(tpl: string) =&gt; string- 可选 excludeAssetFilter -(assetUrl: string) =&gt; boolean- 可选，指定部分特殊的动态加载的微应用资源（css/js) 不被 qiankun 劫持处理 返回值-MicroApp- 微应用实例addGlobalUncaughtErrorHandler 添加全局的未捕获异常处理器。 用法 手动加载一个微应用。 如果需要能支持主应用手动 update 微应用，需要微应用 entry 再多导出一个 update 钩子： 1234567export async function mount(props) { renderApp(props);}// 增加 update 钩子以便主应用手动更新微应用export async function update(props) { renderPatch(props);} 示例1234567891011121314151617181920212223import { loadMicroApp } from 'qiankun';import React from 'react';class App extends React.Component { containerRef = React.createRef(); microApp = null; componentDidMount() { this.microApp = loadMicroApp({ name: 'app1', entry: '//localhost:1234', container: this.containerRef.current, props: { brand: 'qiankun' }, }); } componentWillUnmount() { this.microApp.unmount(); } componentDidUpdate() { this.microApp.update({ name: 'kuitos' }); } render() { return &lt;div ref={this.containerRef}&gt;&lt;/div&gt;; }} 三、当前倍市得框架使用解析 当前倍市得采用qiankun框架，并不完全属于微前端概念，而是采用微组件，将主框架中组件拆分出来为全局组件，通过判断组件是否定制去选择加载主项目或者子项目中的组件，下面通过分析主项目，子项目去了解实现方式 1、主应用技术解析：应用qiankun框架中的loadMicroApp即手动加载微应、*addGlobalUncaughtErrorHandler 流程解析：（1）组件拆分将组件独立出来，将其中引用局部数据的地方修改为引用全局数据（以便拷贝代码到子项目时无需修改代码），将组件信息更新到全局组件维护文件micro.js中 （2）组件挂载路由拦截中获取公司信息后，先对组件信息进行处理 2、子应用技术解析：子应用中主要根据qiankun中生命周期钩子函数去获取主应用数据，并进行组件注册等操作 123456789101112131415161718192021/** * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。 * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。 */export async function bootstrap() { console.log('react app bootstraped');}/** * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法 */export async function mount(props) {}/** * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例 */export async function unmount(props) {}/** * 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效 */export async function update(props) { console.log('update props', props);} 流程解析：（1）组件注册 （2）数据处理 继承主应用传递的vuex数据，与子应用vuex数据进行合并，同名数据覆盖 3、主子项目通信 子应用mount生命周期内对拿到的vuex数据与子应用合并 主应用将Vue实例、utils通用项目工具函数、api通用项目api、global全局枚举数据放置在mainAppData中传递给子组件，子组件在mount中接收到后与本地数据合并 4、脚手架","link":"/2021/04/26/qiankun%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ThreeJs","slug":"ThreeJs","link":"/tags/ThreeJs/"},{"name":"music","slug":"music","link":"/tags/music/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"typeScript","slug":"typeScript","link":"/tags/typeScript/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"音乐","slug":"音乐","link":"/categories/%E9%9F%B3%E4%B9%90/"},{"name":"node","slug":"前端/node","link":"/categories/%E5%89%8D%E7%AB%AF/node/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"typeScript","slug":"前端/typeScript","link":"/categories/%E5%89%8D%E7%AB%AF/typeScript/"},{"name":"ThreeJs","slug":"前端/ThreeJs","link":"/categories/%E5%89%8D%E7%AB%AF/ThreeJs/"},{"name":"框架","slug":"前端/框架","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"}]}