<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>qiankun - Cynqu</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Cynqu"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Cynqu"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="qiankun是基于single-spa 一般来说，微前端需要解决的问题分为两大类： 1. 应用的加载与切换 2. 应用的隔离与通信"><meta property="og:type" content="blog"><meta property="og:title" content="qiankun"><meta property="og:url" content="http://example.com/2021/04/26/qiankun%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"><meta property="og:site_name" content="Cynqu"><meta property="og:description" content="qiankun是基于single-spa 一般来说，微前端需要解决的问题分为两大类： 1. 应用的加载与切换 2. 应用的隔离与通信"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.unsplash.com/photo-1550836445-05aac225729c?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1226&amp;q=80"><meta property="article:published_time" content="2021-04-26T07:37:52.000Z"><meta property="article:modified_time" content="2021-04-27T10:08:11.589Z"><meta property="article:author" content="Cynqu"><meta property="article:tag" content="框架"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://images.unsplash.com/photo-1550836445-05aac225729c?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1226&amp;q=80"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/04/26/qiankun%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"},"headline":"qiankun","image":[],"datePublished":"2021-04-26T07:37:52.000Z","dateModified":"2021-04-27T10:08:11.589Z","author":{"@type":"Person","name":"Cynqu"},"description":"qiankun是基于single-spa 一般来说，微前端需要解决的问题分为两大类： 1. 应用的加载与切换 2. 应用的隔离与通信"}</script><link rel="canonical" href="http://example.com/2021/04/26/qiankun%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Cynqu" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://images.unsplash.com/photo-1550836445-05aac225729c?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1226&amp;q=80" alt="qiankun"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span> / </span><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/">框架</a></span><span class="level-item">1 小时读完 (大约6812个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">qiankun</h1><div class="content"><h1 id="一、qiankun与single-spa实现原理"><a href="#一、qiankun与single-spa实现原理" class="headerlink" title="一、qiankun与single-spa实现原理"></a>一、qiankun与single-spa实现原理</h1><p>qiankun是基于single-spa</p>
<p>一般来说，微前端需要解决的问题分为两大类：</p>
<ol>
<li>应用的加载与切换</li>
<li>应用的隔离与通信</li>
</ol>
<p>应用的加载与切换需要解决的问题包括：<strong>路由问题、应用入口、应用加载</strong>；</p>
<p>应用的隔离与通信需要解决的问题包括：<strong>js隔离、css样式隔离、应用间通信</strong>。</p>
<p><strong>single-spa</strong>很好地解决了<strong>路由</strong>和<strong>应用入口</strong>两个问题，但并没有解决<strong>应用加载</strong>问题，而是将该问题暴露出来由使用者实现（一般可以用<strong>system.js</strong>或<strong>原生script标签</strong>来实现）；<strong>qiankun</strong>在此基础上封装了一个应用加载方案（即<strong>import-html-entry</strong>），并给出了js隔离、css样式隔离和应用间通信三个问题的解决方案，同时提供了预加载功能。</p>
<p>借助<strong>single-spa</strong>提供的能力，我们只能把不同的应用加载到一个页面内，但是很难保证这些应用不会互相干扰。而<strong>qiankun</strong>解决了这些问题，使得它成为一个更加完整的微前端运行时容器。</p>
<h2 id="1、single-spa实现原理"><a href="#1、single-spa实现原理" class="headerlink" title="1、single-spa实现原理"></a>1、single-spa实现原理</h2><h3 id="（1）基础概念"><a href="#（1）基础概念" class="headerlink" title="（1）基础概念"></a>（1）基础概念</h3><ul>
<li><strong>加载器</strong>：也就是微前端架构的核心，主要用来调度子应用，决定何时展示哪个子应用， 可以把它理解成电源。</li>
<li><strong>包装器</strong>：有了加载器，可以把现有的应用包装，使得加载器可以使用它们，它相当于电源适配器。</li>
<li><strong>主应用</strong>：一般是包含所有子应用公共部分的项目—— 它相当于电器底座</li>
<li><strong>子应用</strong>：众多展示在主应用内容区的应用—— 它相当于你要使用的电器，所以是这么个概念：电源(加载器)→电源适配器(包装器)→️电器底座(主应用)→️电器(子应用)️</li>
</ul>
<p>总的来说是这样一个流程：用户访问index.html后，浏览器运行加载器的js文件，加载器去配置文件，然后注册配置文件中配置的各个子应用后，首先加载主应用(菜单等)，再通过路由判定，动态远程加载子应用。</p>
<p><strong>SystemJS</strong>一个运行于浏览器端的模块加载器，提供通用的模块导入途径，支持传统模块和ES6的模块。</p>
<p><strong>SystemJs</strong>有两个版本，6.x版本是在浏览器中使用的，0.21版本的是在浏览器和node环境中使用的，两者的使用方式不同。(参考：<a target="_blank" rel="noopener" href="https://github.com/systemjs/systemjs?fileGuid=cYYhDWjhK9qcKW6w">https://github.com/systemjs/systemjs</a>)</p>
<p>在微服务中相当于<strong>加载器</strong>的角色。</p>
<p><strong>singleSpa</strong></p>
<p>single-spa是一个在前端应用程序中将多个javascript应用集合在一起的框架。相当于<strong>包装器</strong>的角色</p>
<h3 id="（2）路由问题"><a href="#（2）路由问题" class="headerlink" title="（2）路由问题"></a>（2）路由问题</h3><p>single-spa是通过监听<strong>hashChange</strong>和<strong>popState</strong>这两个原生事件来检测路由变化的，它会根据路由的变化来加载对应的应用。</p>
<p>相关的代码可以在<strong>single-spa</strong>的<strong>src/navigation/navigation-events.js</strong>中找到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 139行</span></span><br><span class="line"><span class="keyword">if</span> (isInBrowser) &#123;</span><br><span class="line">  <span class="comment">// We will trigger an app change for any routing events.</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>, urlReroute);</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;popstate&quot;</span>, urlReroute);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 174行，劫持pushState和replaceState</span></span><br><span class="line">  <span class="built_in">window</span>.history.pushState = patchedUpdateState(</span><br><span class="line">    <span class="built_in">window</span>.history.pushState,</span><br><span class="line">    <span class="string">&quot;pushState&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">window</span>.history.replaceState = patchedUpdateState(</span><br><span class="line">    <span class="built_in">window</span>.history.replaceState,</span><br><span class="line">    <span class="string">&quot;replaceState&quot;</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p><strong>single-spa</strong>在检测到发生<strong>hashChange</strong>或<strong>popState</strong>事件时，会执行<strong>urlReroute</strong>函数，这里封装了它对路由问题的解决方案。<br>另外，它还劫持了原生的<strong>pushState</strong>和<strong>replaceState</strong>事件</p>
<p>urlReroute：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlReroute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  reroute([], <span class="built_in">arguments</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>reroute</strong>函数就是<strong>single-spa</strong>解决路由问题的核心逻辑</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reroute</span>(<span class="params">pendingPromises = [], eventArguments</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// getAppChanges会根据路由改变应用的状态，状态包含4类</span></span><br><span class="line">  <span class="comment">// 待清除、待卸载、待加载、待挂载</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    appsToUnload,</span><br><span class="line">    appsToUnmount,</span><br><span class="line">    appsToLoad,</span><br><span class="line">    appsToMount,</span><br><span class="line">  &#125; = getAppChanges();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 如果应用已启动，则调用performAppChanges加载和挂载应用</span></span><br><span class="line">  <span class="comment">// 否则，只加载未加载的应用</span></span><br><span class="line">  <span class="keyword">if</span> (isStarted()) &#123;</span><br><span class="line">    appChangeUnderway = <span class="literal">true</span>;</span><br><span class="line">    appsThatChanged = appsToUnload.concat(</span><br><span class="line">      appsToLoad,</span><br><span class="line">      appsToUnmount,</span><br><span class="line">      appsToMount</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> performAppChanges();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    appsThatChanged = appsToLoad;</span><br><span class="line">    <span class="keyword">return</span> loadApps();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">performAppChanges</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 1. 派发应用更新前的自定义事件</span></span><br><span class="line">      <span class="comment">// 2. 执行应用暴露出的生命周期函数</span></span><br><span class="line">      <span class="comment">// appsToUnload -&gt; unload生命周期钩子</span></span><br><span class="line">      <span class="comment">// appsToLoad -&gt; 执行加载方法</span></span><br><span class="line">      <span class="comment">// appsToUnmount -&gt; 卸载应用，并执行对应生命周期钩子</span></span><br><span class="line">      <span class="comment">// appsToMount -&gt; 尝试引导和挂载应用</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>single-spa</strong>解决路由问题的主要逻辑</p>
<ul>
<li>根据传入的参数<strong>activeWhen</strong>判断哪个应用需要加载，哪个应用需要卸载或清除，并将其push到对应的数组</li>
<li>如果应用已经启动，则进行应用加载或切换。针对应用的不同状态，直接执行应用自身暴露出的生命周期钩子函数即可。</li>
<li>如果应用未启动，则只去下载<strong>appsToLoad</strong>中的应用。</li>
</ul>
<p>总的来看，当路由发生变化时，<strong>hashChange</strong>或<strong>popState</strong>会触发，这时<strong>single-spa</strong>会监听到，并触发<strong>urlReroute</strong>；接着它会调用<strong>reroute</strong>，该函数正确设置各个应用的状态后，直接通过调用应用所暴露出的生命周期钩子函数即可。当某个应用被推送到<strong>appsToMount</strong>后，它的<strong>mount</strong>函数会被调用，该应用就会被挂载；而推送到<strong>appsToUnmount</strong>中的应用则会调用其<strong>unmount</strong>钩子进行卸载。</p>
<h3 id="（3）应用入口"><a href="#（3）应用入口" class="headerlink" title="（3）应用入口"></a>（3）应用入口</h3><p><strong>single-spa</strong>采用的是协议入口，即只要实现了<strong>single-spa</strong>的入口协议规范，它就是可加载的应用。<strong>single-spa</strong>的规范要求应用入口必须暴露出以下三个生命周期钩子函数，且必须返回Promise，以保证<strong>single-spa</strong>可以注册回调函数：</p>
<ol>
<li>bootstrap</li>
<li>mount</li>
<li>unmount</li>
</ol>
<p><img src="https://uploader.shimo.im/f/qhvdFHRmJ47Ngyxj.png!thumbnail?fileGuid=cYYhDWjhK9qcKW6w" alt="图片"></p>
<p><strong>bootstrap</strong>用于应用引导，基座应用会在子应用挂载前调用它。</p>
<p><strong>mount</strong>用于应用挂载，就是一般应用中用于渲染的逻辑，即上述的new Vue语句。我们通常会把它封装到一个函数里，在mount钩子函数中调用。</p>
<p><strong>unmount</strong>用于应用卸载，我们可以在这里调用实例的destroy方法手动卸载应用，或清除某些内存占用等。</p>
<p>除了以上三个必须实现的钩子外，<strong>single-spa</strong>还支持非必须的<strong>load</strong>、<strong>unload</strong>、<strong>update</strong>等，分别用于加载、卸载和更新应用。</p>
<h3 id="（4）应用加载"><a href="#（4）应用加载" class="headerlink" title="（4）应用加载"></a>（4）应用加载</h3><p>基于<strong>system.js</strong>如何启动<strong>single-spa</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;systemjs-importmap&quot;</span>&gt;</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="javascript">    <span class="string">&quot;imports&quot;</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;app1&quot;</span>: <span class="string">&quot;http://localhost:8080/app1.js&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;app2&quot;</span>: <span class="string">&quot;http://localhost:8081/app2.js&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;single-spa&quot;</span>: <span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/single-spa/4.3.7/system/single-spa.min.js&quot;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">... // system.js的相关依赖文件</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 加载single-spa</span></span></span><br><span class="line"><span class="javascript">  System.import(<span class="string">&#x27;single-spa&#x27;</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> singleSpa = res;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 注册子应用</span></span></span><br><span class="line"><span class="javascript">    singleSpa.registerApplication(<span class="string">&#x27;app1&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      () =&gt; System.import(<span class="string">&#x27;app1&#x27;</span>),</span></span><br><span class="line"><span class="javascript">      location =&gt; location.hash.startsWith(<span class="string">`#/app1`</span>);</span></span><br><span class="line">    );</span><br><span class="line"><span class="javascript">    singleSpa.registerApplication(<span class="string">&#x27;app2&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      () =&gt; System.import(<span class="string">&#x27;app2&#x27;</span>),</span></span><br><span class="line"><span class="javascript">      location =&gt; location.hash.startsWith(<span class="string">`#/app2`</span>);</span></span><br><span class="line">    );</span><br><span class="line"><span class="javascript">    <span class="comment">// 启动single-spa</span></span></span><br><span class="line">    singleSpa.start();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>在调用<strong>singleSpa.registerApplication</strong>注册应用时提供的第二个参数就是加载这个子应用的方法。<br>如果需要加载多个js，可以使用多个<strong>System.import</strong>连续导入。<strong>single-spa</strong>会调用这个函数，下载子应用代码并分别调用其<strong>bootstrap</strong>和<strong>mount</strong>方法进行引导和挂载。</p>
<p>从这里我们也可以看到<strong>single-spa</strong>的弊端。首先我们必须手动实现应用加载逻辑，挨个罗列子应用需要加载的资源，这在大型项目里是十分困难的（特别是使用了文件名hash时）；另外它只能以js文件为入口，无法直接以html为入口，这使得嵌入子应用变得很困难，也正因此，<strong>single-spa</strong>不能直接加载jQuery应用。</p>
<p><strong>single-spa</strong>的<strong>start</strong>方法也很简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  started = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (opts &amp;&amp; opts.urlRerouteOnly) &#123;</span><br><span class="line">    setUrlRerouteOnly(opts.urlRerouteOnly);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isInBrowser) &#123;</span><br><span class="line">    reroute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>先是设置<strong>started</strong>状态，然后设置我们上面说到的<strong>urlRerouteOnly</strong>属性，接着调用<strong>reroute</strong>，开始首次加载子应用。加载完第一个应用后，<strong>single-spa</strong>就时刻等待着<strong>hashChange</strong>或<strong>popState</strong>事件的触发，并执行应用的切换。<br>以上就是<strong>single-spa</strong>的核心原理，从上面的介绍中不难看出，single-spa只是负责把应用加载到一个页面中，至于应用能否协同工作，是很难保证的。而qiankun所要解决的，就是协同工作的问题。</p>
<h3 id="（5）应用示例"><a href="#（5）应用示例" class="headerlink" title="（5）应用示例"></a>（5）应用示例</h3><p>简单示例：</p>
<p><a target="_blank" rel="noopener" href="https://zh-hans.single-spa.js.org/docs/getting-started-overview?fileGuid=cYYhDWjhK9qcKW6w">https://zh-hans.single-spa.js.org/docs/getting-started-overview</a></p>
<p>vue示例：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/vue-microfrontends?fileGuid=cYYhDWjhK9qcKW6w">https://github.com/vue-microfrontends</a></p>
<h2 id="2、qiankun实现原理"><a href="#2、qiankun实现原理" class="headerlink" title="2、qiankun实现原理"></a>2、qiankun实现原理</h2><h3 id="（1）应用加载"><a href="#（1）应用加载" class="headerlink" title="（1）应用加载"></a>（1）应用加载</h3><p><strong>single-spa</strong>提供的应用加载方案是开放式的。针对上面的几个弊端，<strong>qiankun</strong>进行了一次封装，给出了一个更完整的应用加载方案，<strong>qiankun</strong>将其封装成了npm插件<strong>import-html-entry</strong>。</p>
<p>该方案的主要思路是允许以html文件为应用入口，然后通过一个html解析器从文件中提取js和css依赖，并通过fetch下载依赖，于是在<strong>qiankun</strong>中你可以这样配置入口：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MicroApps = [&#123;</span><br><span class="line">  name: <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">  entry: <span class="string">&#x27;http://localhost:8080&#x27;</span>,</span><br><span class="line">  container: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  activeRule: <span class="string">&#x27;/app1&#x27;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p><strong>qiankun</strong>会通过<strong>import-html-entry</strong>请求<strong><a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a></strong>，得到对应的html文件，解析内部的所有<strong>script</strong>和<strong>style</strong>标签，依次下载和执行它们，这使得应用加载变得更易用。<br><strong>import-html-entry</strong>暴露出的核心接口是<strong>importHTML</strong>，用于加载html文件，它支持两个参数：</p>
<ol>
<li><strong>url</strong>，要加载的文件地址，一般是服务中html的地址</li>
<li><strong>opts</strong>，配置参数</li>
</ol>
<p>url不必多说。opts如果是一个函数，则会替换默认的fetch作为下载文件的方法，此时其返回值应当是Promise；如果是一个对象，那么它最多支持四个属性：<strong>fetch</strong>、<strong>getPublicPath</strong>、<strong>getDomain</strong>、<strong>getTemplate</strong>，用于替换默认的方法。</p>
<p>截取该函数的主要逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">importHTML</span>(<span class="params">url, opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 如果已经加载过，则从缓存返回，否则fetch回来并保存到缓存中</span></span><br><span class="line">  <span class="keyword">return</span> embedHTMLCache[url] || (embedHTMLCache[url] = fetch(url)</span><br><span class="line">		.then(<span class="function"><span class="params">response</span> =&gt;</span> readResAsString(response, autoDecodeResponse))</span><br><span class="line">		.then(<span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">		  <span class="comment">// 对html字符串进行初步处理</span></span><br><span class="line">		  <span class="keyword">const</span> &#123; template, scripts, entry, styles &#125; = </span><br><span class="line">		    processTpl(getTemplate(html), assetPublicPath);</span><br><span class="line">		  <span class="comment">// 先将外部样式处理成内联样式</span></span><br><span class="line">		  <span class="comment">// 然后返回几个核心的脚本及样式处理方法</span></span><br><span class="line">		  <span class="keyword">return</span> getEmbedHTML(template, styles, &#123; fetch &#125;).then(<span class="function"><span class="params">embedHTML</span> =&gt;</span> (&#123;</span><br><span class="line">				template: embedHTML,</span><br><span class="line">				assetPublicPath,</span><br><span class="line">				getExternalScripts: <span class="function">() =&gt;</span> getExternalScripts(scripts, fetch),</span><br><span class="line">				getExternalStyleSheets: <span class="function">() =&gt;</span> getExternalStyleSheets(styles, fetch),</span><br><span class="line">				execScripts: <span class="function">(<span class="params">proxy, strictGlobal, execScriptsHooks = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (!scripts.length) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> execScripts(entry, scripts, proxy, &#123;</span><br><span class="line">						fetch,</span><br><span class="line">						strictGlobal,</span><br><span class="line">						beforeExec: execScriptsHooks.beforeExec,</span><br><span class="line">						afterExec: execScriptsHooks.afterExec,</span><br><span class="line">					&#125;);</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略的部分主要是一些参数预处理，我们从return语句开始看，具体过程如下：</p>
<ol>
<li>检查是否有缓存，如果有，直接从缓存中返回</li>
<li>如果没有，则通过fetch下载，并字符串化</li>
<li>调用<strong>processTpl</strong>进行一次模板解析，主要任务是扫描出外联脚本和外联样式，保存在<strong>scripts</strong>和<strong>styles</strong>中</li>
<li>调用<strong>getEmbedHTML</strong>，将外联样式下载下来，并替换到模板内，使其变成内部样式</li>
<li>返回一个对象，该对象包含处理后的模板，以及<strong>getExternalScripts</strong>、<strong>getExternalStyleSheets</strong>、<strong>execScripts</strong>等几个核心方法。</li>
</ol>
<p><img src="https://uploader.shimo.im/f/JrPlRiJS31OrFCGq.png!thumbnail?fileGuid=cYYhDWjhK9qcKW6w" alt="图片"></p>
<p><strong>processTpl</strong>主要基于正则表达式对模板字符串进行解析。我们来看<strong>getExternalScripts</strong>、<strong>getExternalStyleSheets</strong>、<strong>execScripts</strong>这三个方法：</p>
<p><strong>getExternalStyleSheets</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getExternalStyleSheets</span>(<span class="params">styles, fetch = defaultFetch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(styles.map(<span class="function"><span class="params">styleLink</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (isInlineCode(styleLink)) &#123;</span><br><span class="line">	  <span class="comment">// if it is inline style</span></span><br><span class="line">	  <span class="keyword">return</span> getInlineCode(styleLink);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  <span class="comment">// external styles</span></span><br><span class="line">	  <span class="keyword">return</span> styleCache[styleLink] ||</span><br><span class="line">	  (styleCache[styleLink] = fetch(styleLink).then(<span class="function"><span class="params">response</span> =&gt;</span> response.text()));</span><br><span class="line">	&#125;</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历styles数组，如果是内联样式，则直接返回；否则判断缓存中是否存在，如果没有，则通过fetch去下载，并进行缓存。<br><strong>getExternalScripts</strong>与上述过程类似。</p>
<p><strong>execScripts</strong>是实现js隔离的核心方法。</p>
<p>通过调用<strong>importHTML</strong>方法，<strong>qiankun</strong>可以直接加载html文件，同时将外联样式处理成内部样式表，并且解析出JavaScript依赖。更重要的是，它获得了一个可以在隔离环境下执行应用脚本的方法<strong>execScripts</strong>。</p>
<h3 id="（2）js隔离"><a href="#（2）js隔离" class="headerlink" title="（2）js隔离"></a>（2）js隔离</h3><p><strong>qiankun</strong>通过<strong>import-html-entry</strong>，可以对html入口进行解析，并获得一个可以执行脚本的方法<strong>execScripts</strong>。<strong>qiankun</strong>引入该接口后，首先为该应用生成一个window的代理对象，然后将代理对象作为参数传入接口，以保证应用内的js不会对全局<strong>window</strong>造成影响。由于IE11不支持proxy，所以<strong>qiankun</strong>通过快照策略来隔离js，缺点是无法支持多实例场景。</p>
<p>我们先来看基于<strong>proxy</strong>的js隔离是如何实现的。首先看<strong>import-html-entry</strong>暴露出的接口，截取核心代码:</p>
<p><strong>execScripts</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">execScripts</span>(<span class="params">entry, scripts, proxy = <span class="built_in">window</span>, opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  ... <span class="comment">// 初始化参数</span></span><br><span class="line">  <span class="keyword">return</span> getExternalScripts(scripts, fetch, error)</span><br><span class="line">	.then(<span class="function"><span class="params">scriptsText</span> =&gt;</span> &#123;</span><br><span class="line">	  <span class="comment">// 在proxy对象下执行脚本的方法</span></span><br><span class="line">	  <span class="keyword">const</span> geval = <span class="function">(<span class="params">scriptSrc, inlineScript</span>) =&gt;</span> &#123;</span><br><span class="line">	    <span class="keyword">const</span> rawCode = beforeExec(inlineScript, scriptSrc) || inlineScript;</span><br><span class="line">	    <span class="keyword">const</span> code = getExecutableScript(scriptSrc, rawCode, proxy, strictGlobal);</span><br><span class="line">        (<span class="number">0</span>, <span class="built_in">eval</span>)(code);</span><br><span class="line">        afterExec(inlineScript, scriptSrc);</span><br><span class="line">	  &#125;;</span><br><span class="line">	  <span class="comment">// 执行单个脚本的方法</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">exec</span> (<span class="params">scriptSrc, inlineScript, resolve</span>) </span>&#123; ... &#125;</span><br><span class="line">      <span class="comment">// 排期函数，负责逐个执行脚本</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">schedule</span>(<span class="params">i, resolvePromise</span>) </span>&#123; ... &#125;</span><br><span class="line">      <span class="comment">// 启动排期函数，执行脚本</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> schedule(<span class="number">0</span>, success || resolve));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个函数的关键是定义了三个函数：<strong>geval</strong>、<strong>exec</strong>、<strong>schedule</strong>，其中实现js隔离的是<strong>geval</strong>函数内调用的<strong>getExecutableScript</strong>函数。我们看到，在调这个函数时，我们把外部传入的<strong>proxy</strong>作为参数传入了进去，而它返回的是一串新的脚本字符串，这段新的字符串内的<strong>window</strong>已经被<strong>proxy</strong>替代，具体实现逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getExecutableScript</span>(<span class="params">scriptSrc, scriptText, proxy, strictGlobal</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> sourceUrl = isInlineCode(scriptSrc) ? <span class="string">&#x27;&#x27;</span> : <span class="string">`//# sourceURL=<span class="subst">$&#123;scriptSrc&#125;</span>\n`</span>;</span><br><span class="line">	<span class="comment">// 通过这种方式获取全局 window，因为 script 也是在全局作用域下运行的，所以我们通过 window.proxy 绑定时也必须确保绑定到全局 window 上</span></span><br><span class="line">	<span class="comment">// 否则在嵌套场景下， window.proxy 设置的是内层应用的 window，而代码其实是在全局作用域运行的，会导致闭包里的 window.proxy 取的是最外层的微应用的 proxy</span></span><br><span class="line">	<span class="keyword">const</span> globalWindow = (<span class="number">0</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;window&#x27;</span>);</span><br><span class="line">	globalWindow.proxy = proxy;</span><br><span class="line">	<span class="comment">// TODO 通过 strictGlobal 方式切换切换 with 闭包，待 with 方式坑趟平后再合并</span></span><br><span class="line">	<span class="keyword">return</span> strictGlobal</span><br><span class="line">		? <span class="string">`;(function(window, self, globalThis)&#123;with(window)&#123;;<span class="subst">$&#123;scriptText&#125;</span>\n<span class="subst">$&#123;sourceUrl&#125;</span>&#125;&#125;).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`</span></span><br><span class="line">		: <span class="string">`;(function(window, self, globalThis)&#123;;<span class="subst">$&#123;scriptText&#125;</span>\n<span class="subst">$&#123;sourceUrl&#125;</span>&#125;).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://uploader.shimo.im/f/gjqaIIvkkjaKXxqC.png!thumbnail?fileGuid=cYYhDWjhK9qcKW6w" alt="图片"></h3><p>核心代码就是由两个矩形框起来的部分，它把解析出的<strong>scriptText</strong>（即脚本字符串）用<strong>with(window){}<strong>包裹起来，然后把</strong>window.proxy</strong>作为函数的第一个参数传进来，所以<strong>with</strong>语法内的<strong>window</strong>实际上是<strong>window.proxy</strong>。</p>
<p>这样，当在执行这段代码时，所有类似<strong>var name = ‘张三’<strong>这样的语句添加的全局变量</strong>name</strong>，实际上是被挂载到了<strong>window.proxy</strong>上，而不是真正的全局<strong>window</strong>上。当应用被卸载时，对应的<strong>proxy</strong>会被清除，因此不会导致js污染。而当你配置<strong>webpack</strong>的打包类型为<strong>lib</strong>时，你得到的接口大概如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jquery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)();</span><br></pre></td></tr></table></figure>
<p>如果你的应用内使用了jquery，那么这个jquery对象就会被挂载到<strong>window.proxy</strong>上。不过如果你在代码内直接写<strong>window.name = ‘张三’<strong>来生成全局变量，那么</strong>qiankun</strong>就无法隔离js污染了。<br><strong>import-html-entry</strong>实现了上述能力后，<strong>qiankun</strong>要做的就很简单了，只需要在加载一个应用时为其初始化一个<strong>proxy</strong>传递进来即可：</p>
<p><strong>proxySandbox.ts</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySandbox</span> <span class="title">implements</span> <span class="title">SandBox</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: string</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(fakeWindow, &#123;</span><br><span class="line">      set () &#123; ... &#125;,</span><br><span class="line">      get () &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次加载一个应用，<strong>qiankun</strong>就初始化这样一个<strong>proxySandbox</strong>，传入上述<strong>execScripts</strong>函数中。<br>在IE下，由于<strong>proxy</strong>不被支持，并且没有可用的<strong>polyfill</strong>，所以<strong>qiankun</strong>退而求其次，采用快照策略实现js隔离。它的大致思路是，在加载应用前，将<strong>window</strong>上的所有属性保存起来（即拍摄快照）；等应用被卸载时，再恢复<strong>window</strong>上的所有属性，这样也可以防止全局污染。但是当页面同时存在多个应用实例时，<strong>qiankun</strong>无法将其隔离开，所以IE下的快照策略无法支持多实例模式。</p>
<h3 id="（3）css隔离"><a href="#（3）css隔离" class="headerlink" title="（3）css隔离"></a>（3）css隔离</h3><p>目前<strong>qiankun</strong>主要提供了两种样式隔离方案，一种是基于<strong>shadowDom</strong>的；另一种则是实验性的，思路类似于Vue中的<strong>scoped</strong>属性，给每个子应用的根节点添加一个特殊属性，用作对所有css选择器的约束。</p>
<p>开启样式隔离的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">registerMicroApps(&#123;</span><br><span class="line">  name: <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">  sandbox: &#123;</span><br><span class="line">    strictStyleIsolation: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 实验性方案，scoped方式</span></span><br><span class="line">    <span class="comment">// experimentalStyleIsolation: true</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当启用<strong>strictStyleIsolation</strong>时，<strong>qiankun</strong>将采用<strong>shadowDom</strong>的方式进行样式隔离，即为子应用的根节点创建一个<strong>shadow root。</strong>最终整个应用的所有DOM将形成一棵<strong>shadow tree。</strong>我们知道，<strong>shadowDom</strong>的特点是<strong>，它</strong>内部所有节点的样式对树外面的节点无效，因此自然就实现了样式隔离。<br>但是这种方案是存在缺陷的。因为某些UI框架可能会生成一些弹出框直接挂载到<strong>document.body</strong>下，此时由于脱离了<strong>shadow tree</strong>，所以它的样式仍然会对全局造成污染。</p>
<p>此外<strong>qiankun</strong>也在探索类似于<strong>scoped</strong>属性的样式隔离方案，可以通过<strong>experimentalStyleIsolation</strong>来开启。这种方案的策略是为子应用的根节点添加一个特定的随机属性，如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  data-qiankun-asiw732sde</span><br><span class="line">  id=&quot;__qiankun_microapp_wrapper__&quot;</span><br><span class="line">  data-name=&quot;module-app1&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>然后为所有样式前面都加上这样的约束：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.app-main</span> &#123; </span><br><span class="line">  字体大小：<span class="number">14</span> px ; </span><br><span class="line">&#125;</span><br><span class="line">// -&gt;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[data-qiankun-asiw732sde]</span> <span class="selector-class">.app-main</span> &#123;  </span><br><span class="line">  字体大小：<span class="number">14</span> px ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上述替换，这个样式就只能在当前子应用内生效了。虽然该方案已经提出很久了，但仍然是实验性的，因为它不支持@ keyframes，@ font-face，@ import，@ page（即不会被重写）。</p>
<h3 id="（4）应用通信"><a href="#（4）应用通信" class="headerlink" title="（4）应用通信"></a>（4）应用通信</h3><p>一般来说，微前端中各个应用之前的通信应该是尽量少的，而这依赖于应用的合理拆分。反过来说，如果你发现两个应用间存在极其频繁的通信，那么一般是拆分不合理造成的，这时往往需要将它们合并成一个应用。</p>
<p>当然了，应用间存在少量的通信是难免的。<strong>qiankun</strong>官方提供了一个简要的方案，思路是基于一个全局的<strong>globalState</strong>对象。这个对象由基座应用负责创建，内部包含一组用于通信的变量，以及两个分别用于修改变量值和监听变量变化的方法：<strong>setGlobalState</strong>和<strong>onGlobalStateChange</strong>。</p>
<p>以下代码用于在基座应用中初始化它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initGlobalState, MicroAppStateActions &#125; <span class="keyword">from</span> <span class="string">&#x27;qiankun&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> actions: MicroAppStateActions = initGlobalState(initialState);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> actions;</span><br></pre></td></tr></table></figure>
<p>这里的<strong>actions</strong>对象就是我们说的<strong>globalState</strong>，即全局状态。基座应用可以在加载子应用时通过<strong>props</strong>将<strong>actions</strong>传递到子应用内，而子应用通过以下语句即可监听全局状态变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actions.onGlobalStateChange (globalState, oldGlobalState) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，子应用也可以修改全局状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actions.setGlobalState(...);</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/VaY36CMuSj29V037.png!thumbnail?fileGuid=cYYhDWjhK9qcKW6w" alt="图片"></p>
<p>此外，基座应用和其他子应用也可以进行这两个操作，从而实现对全局状态的共享，这样各个应用之间就可以通信了。这种方案与Redux和Vuex都有相似之处，只是由于微前端中的通信问题较为简单，所以官方只提供了这样一个精简方案。关于其实现原理这里不再赘述，感兴趣的可以去看一下源码。</p>
<h1 id="二、qiankun应用"><a href="#二、qiankun应用" class="headerlink" title="二、qiankun应用"></a>二、qiankun应用</h1><h2 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h2><h2 id="（1）基于路由配置"><a href="#（1）基于路由配置" class="headerlink" title="（1）基于路由配置"></a>（1）基于路由配置</h2><p>适用于 route-based 场景。</p>
<p>通过将微应用关联到一些 url 规则的方式，实现当浏览器 url 发生变化时，自动加载相应的微应用的功能。</p>
<h3 id="registerMicroApps-apps-lifeCycles-注册应用"><a href="#registerMicroApps-apps-lifeCycles-注册应用" class="headerlink" title="registerMicroApps(apps, lifeCycles?) 注册应用"></a>registerMicroApps(apps, lifeCycles?) 注册应用</h3><ul>
<li>参数<ul>
<li>apps -****<strong>Array<RegistrableApp></strong>- 必选，微应用的一些注册信息</li>
<li>lifeCycles -<strong>LifeCycles</strong>- 可选，全局的微应用生命周期钩子</li>
</ul>
</li>
<li>类型<ul>
<li><strong>RegistrableApp</strong><ul>
<li>name -<strong>string</strong>- 必选，微应用的名称，微应用之间必须确保唯一。</li>
<li>entry -<strong>string | { scripts?: string[]; styles?: string[]; html?: string }</strong>- 必选，微应用的入口。<ul>
<li>配置为字符串时，表示微应用的访问地址，例如**<a target="_blank" rel="noopener" href="https://qiankun.umijs.org/guide/**%E3%80%82">https://qiankun.umijs.org/guide/**。</a></li>
<li>配置为对象时，<strong>html</strong>的值是微应用的 html 内容字符串，而不是微应用的访问地址。微应用的<strong>publicPath</strong>将会被设置为**/**。</li>
</ul>
</li>
<li>container -<strong>string | HTMLElement</strong>- 必选，微应用的容器节点的选择器或者 Element 实例。如**container: ‘#root’<strong>或</strong>container: document.querySelector(‘#root’)**。</li>
<li>activeRule -<strong>string | (location: Location) =&gt; boolean | Array&lt;string | (location: Location) =&gt; boolean&gt;</strong>- 必选，微应用的激活规则。</li>
</ul>
</li>
<li><strong>LifeCycles 生命周期</strong></li>
</ul>
</li>
<li>用法</li>
</ul>
<p>注册微应用的基础配置信息。当浏览器 url 发生变化时，会自动检查每一个微应用注册的<strong>activeRule</strong>规则，符合规则的应用将会被自动激活。</p>
<ul>
<li><p>示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; registerMicroApps &#125; <span class="keyword">from</span> <span class="string">&#x27;qiankun&#x27;</span>;</span><br><span class="line">registerMicroApps(</span><br><span class="line">  [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">      entry: <span class="string">&#x27;//localhost:8080&#x27;</span>,</span><br><span class="line">      container: <span class="string">&#x27;#container&#x27;</span>,</span><br><span class="line">      activeRule: <span class="string">&#x27;/react&#x27;</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        name: <span class="string">&#x27;kuitos&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  &#123;</span><br><span class="line">    beforeLoad: <span class="function">(<span class="params">app</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;before load&#x27;</span>, app.name),</span><br><span class="line">    beforeMount: [<span class="function">(<span class="params">app</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;before mount&#x27;</span>, app.name)],</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="start-opts"><a href="#start-opts" class="headerlink" title="start(opts?)"></a><strong>start(opts?)</strong></h3></li>
<li><p>用法</p>
</li>
</ul>
<p>启动 qiankun。</p>
<ul>
<li>示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; start &#125; <span class="keyword">from</span> <span class="string">&#x27;qiankun&#x27;</span>;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure>
<h2 id="2-手动加载微应用"><a href="#2-手动加载微应用" class="headerlink" title="(2)手动加载微应用"></a>(2)手动加载微应用</h2></li>
</ul>
<p>适用于需要手动 加载/卸载 一个微应用的场景。</p>
<p>通常这种场景下微应用是一个不带路由的可独立运行的业务组件。 微应用不宜拆分过细，建议按照业务域来做拆分。业务关联紧密的功能单元应该做成一个微应用，反之关联不紧密的可以考虑拆分成多个微应用。 一个判断业务关联是否紧密的标准：<strong>看这个微应用与其他微应用是否有频繁的通信需求</strong>。如果有可能说明这两个微应用本身就是服务于同一个业务场景，合并成一个微应用可能会更合适。</p>
<h3 id="loadMicroApp（app-configuration-）手动加载子应用"><a href="#loadMicroApp（app-configuration-）手动加载子应用" class="headerlink" title="loadMicroApp（app, configuration?）手动加载子应用"></a><strong>loadMicroApp（app, configuration?）手动加载子应用</strong></h3><ul>
<li>参数<ul>
<li>app 微应用基础信息<ul>
<li>name</li>
<li>entry</li>
<li>container</li>
<li>props(可通过此参数传递主应用数据到子应用，包括vuex、router、全局方法，mixins等数据)</li>
</ul>
</li>
<li>configuration  微应用配置信息<ul>
<li>sandbox -<strong>boolean | { strictStyleIsolation?: boolean, experimentalStyleIsolation?: boolean }</strong>- 可选，是否开启沙箱，默认为<strong>true</strong>。</li>
<li>singular -<strong>boolean | ((app: RegistrableApp<any>) =&gt; Promise<boolean>);</strong>- 可选，是否为单实例场景，单实例指的是同一时间只会渲染一个微应用。默认为<strong>false</strong>。</li>
<li>fetch -<strong>Function</strong>- 可选，自定义的 fetch 方法。</li>
<li>getPublicPath -<strong>(entry: Entry) =&gt; string</strong>- 可选，参数是微应用的 entry 值。</li>
<li>getTemplate -<strong>(tpl: string) =&gt; string</strong>- 可选</li>
<li>excludeAssetFilter -<strong>(assetUrl: string) =&gt; boolean</strong>- 可选，指定部分特殊的动态加载的微应用资源（css/js) 不被 qiankun 劫持处理</li>
</ul>
</li>
</ul>
</li>
<li>返回值-<strong>MicroApp</strong>- 微应用实例<h3 id="addGlobalUncaughtErrorHandler"><a href="#addGlobalUncaughtErrorHandler" class="headerlink" title="addGlobalUncaughtErrorHandler"></a><strong>addGlobalUncaughtErrorHandler</strong></h3></li>
</ul>
<p>添加全局的未捕获异常处理器。</p>
<ul>
<li>用法</li>
</ul>
<p>手动加载一个微应用。</p>
<p>如果需要能支持主应用手动 update 微应用，需要微应用 entry 再多导出一个 update 钩子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  renderApp(props);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增加 update 钩子以便主应用手动更新微应用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  renderPatch(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; loadMicroApp &#125; <span class="keyword">from</span> <span class="string">&#x27;qiankun&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  containerRef = React.createRef();</span><br><span class="line">  microApp = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.microApp = loadMicroApp(&#123;</span><br><span class="line">      name: <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">      entry: <span class="string">&#x27;//localhost:1234&#x27;</span>,</span><br><span class="line">      container: <span class="built_in">this</span>.containerRef.current,</span><br><span class="line">      props: &#123; <span class="attr">brand</span>: <span class="string">&#x27;qiankun&#x27;</span> &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.microApp.unmount();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.microApp.update(&#123; <span class="attr">name</span>: <span class="string">&#x27;kuitos&#x27;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.containerRef&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、当前倍市得框架使用解析"><a href="#三、当前倍市得框架使用解析" class="headerlink" title="三、当前倍市得框架使用解析"></a>三、当前倍市得框架使用解析</h1></li>
</ul>
<p>当前倍市得采用<strong>qiankun</strong>框架，并不完全属于微前端概念，而是采用微组件，将主框架中组件拆分出来为全局组件，通过判断组件是否定制去选择加载主项目或者子项目中的组件，下面通过分析主项目，子项目去了解实现方式</p>
<h2 id="1、主应用"><a href="#1、主应用" class="headerlink" title="1、主应用"></a>1、主应用</h2><h3 id="技术解析："><a href="#技术解析：" class="headerlink" title="技术解析："></a>技术解析：</h3><p><em>应用qiankun框架中的<strong>loadMicroApp</strong>即手动加载微应、*<em>addGlobalUncaughtErrorHandler</em></em></p>
<h3 id="流程解析："><a href="#流程解析：" class="headerlink" title="流程解析："></a>流程解析：</h3><h4 id="（1）组件拆分"><a href="#（1）组件拆分" class="headerlink" title="（1）组件拆分"></a>（1）组件拆分</h4><p>将组件独立出来，将其中引用局部数据的地方修改为引用全局数据（以便拷贝代码到子项目时无需修改代码），将组件信息更新到全局组件维护文件micro.js中</p>
<p><img src="https://uploader.shimo.im/f/8vka90IOSutmNiUH.png!thumbnail?fileGuid=cYYhDWjhK9qcKW6w" alt="图片"></p>
<h4 id="（2）组件挂载"><a href="#（2）组件挂载" class="headerlink" title="（2）组件挂载"></a>（2）组件挂载</h4><p>路由拦截中获取公司信息后，先对组件信息进行处理</p>
<p><img src="https://uploader.shimo.im/f/8GrhGLoMrIvoXorj.png!thumbnail?fileGuid=cYYhDWjhK9qcKW6w" alt="图片"></p>
<h2 id="2、子应用"><a href="#2、子应用" class="headerlink" title="2、子应用"></a>2、子应用</h2><h3 id="技术解析：-1"><a href="#技术解析：-1" class="headerlink" title="技术解析："></a>技术解析：</h3><p>子应用中主要根据qiankun中生命周期钩子函数去获取主应用数据，并进行组件注册等操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。</span></span><br><span class="line"><span class="comment"> * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;react app bootstraped&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">props</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;update props&#x27;</span>, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流程解析：-1"><a href="#流程解析：-1" class="headerlink" title="流程解析："></a>流程解析：</h3><h4 id="（1）组件注册"><a href="#（1）组件注册" class="headerlink" title="（1）组件注册"></a>（1）组件注册</h4><p><img src="https://uploader.shimo.im/f/WlayGatXnMjUgPRp.png!thumbnail?fileGuid=cYYhDWjhK9qcKW6w" alt="图片"></p>
<h4 id="（2）数据处理"><a href="#（2）数据处理" class="headerlink" title="（2）数据处理"></a>（2）数据处理</h4><ul>
<li><p>继承主应用传递的vuex数据，与子应用vuex数据进行合并，同名数据覆盖</p>
<h2 id="3、主子项目通信"><a href="#3、主子项目通信" class="headerlink" title="3、主子项目通信"></a>3、主子项目通信</h2></li>
<li><p>子应用mount生命周期内对拿到的vuex数据与子应用合并</p>
</li>
<li><p>主应用将Vue实例、utils通用项目工具函数、api通用项目api、global全局枚举数据放置在mainAppData中传递给子组件，子组件在mount中接收到后与本地数据合并</p>
<h2 id="4、脚手架"><a href="#4、脚手架" class="headerlink" title="4、脚手架"></a>4、脚手架</h2></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>qiankun</p><p><a href="http://example.com/2021/04/26/qiankun框架学习/">http://example.com/2021/04/26/qiankun框架学习/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Cynqu</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-04-26</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-04-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/04/26/JS%E5%8E%9F%E5%9E%8B%E6%A2%B3%E7%90%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JS原型梳理</span></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-160x160 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Cynqu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Cynqu</p><p class="is-size-6 is-block">To The Sky</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Cynqu" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Cynqu"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="weibo" href="https://m.weibo.cn/u/2122503823"><i class="fab fa-weibo"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-27T08:26:55.000Z">2021-04-27</time></p><p class="title"><a href="/2021/04/27/%E7%94%9F%E6%88%90%E5%BA%94%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%AD%A6%E4%B9%A0/">生成应用脚手架学习</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a href="/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/">框架</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-27T07:57:48.000Z">2021-04-27</time></p><p class="title"><a href="/2021/04/27/The%20Cure/">The Cure!</a></p><p class="categories"><a href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-27T07:22:03.000Z">2021-04-27</time></p><p class="title"><a href="/2021/04/27/Three-js%E5%88%9D%E6%8E%A2/">Three.js初探</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a href="/categories/%E5%89%8D%E7%AB%AF/ThreeJs/">ThreeJs</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-27T07:18:44.000Z">2021-04-27</time></p><p class="title"><a href="/2021/04/27/%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E7%AE%80%E6%98%93%E7%89%88/">大文件分片上传简易版</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/">JavaScript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-27T07:00:17.000Z">2021-04-27</time></p><p class="title"><a href="/2021/04/27/express%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">express学习笔记</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a href="/categories/%E5%89%8D%E7%AB%AF/node/">node</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100%" height="86" src="//music.163.com/outchain/player?type=2&amp;id=21969945&amp;auto=0&amp;height=66"></iframe><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、qiankun与single-spa实现原理"><span class="level-left"><span class="level-item">1</span><span class="level-item">一、qiankun与single-spa实现原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、single-spa实现原理"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">1、single-spa实现原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#（1）基础概念"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">（1）基础概念</span></span></a></li><li><a class="level is-mobile" href="#（2）路由问题"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">（2）路由问题</span></span></a></li><li><a class="level is-mobile" href="#（3）应用入口"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">（3）应用入口</span></span></a></li><li><a class="level is-mobile" href="#（4）应用加载"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">（4）应用加载</span></span></a></li><li><a class="level is-mobile" href="#（5）应用示例"><span class="level-left"><span class="level-item">1.1.5</span><span class="level-item">（5）应用示例</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2、qiankun实现原理"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">2、qiankun实现原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#（1）应用加载"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">（1）应用加载</span></span></a></li><li><a class="level is-mobile" href="#（2）js隔离"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">（2）js隔离</span></span></a></li><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item"> </span></span></a></li><li><a class="level is-mobile" href="#（3）css隔离"><span class="level-left"><span class="level-item">1.2.4</span><span class="level-item">（3）css隔离</span></span></a></li><li><a class="level is-mobile" href="#（4）应用通信"><span class="level-left"><span class="level-item">1.2.5</span><span class="level-item">（4）应用通信</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#二、qiankun应用"><span class="level-left"><span class="level-item">2</span><span class="level-item">二、qiankun应用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、基础概念"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">1、基础概念</span></span></a></li><li><a class="level is-mobile" href="#（1）基于路由配置"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">（1）基于路由配置</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#registerMicroApps-apps-lifeCycles-注册应用"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">registerMicroApps(apps, lifeCycles?) 注册应用</span></span></a></li><li><a class="level is-mobile" href="#start-opts"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">start(opts?)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-手动加载微应用"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">(2)手动加载微应用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#loadMicroApp（app-configuration-）手动加载子应用"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">loadMicroApp（app, configuration?）手动加载子应用</span></span></a></li><li><a class="level is-mobile" href="#addGlobalUncaughtErrorHandler"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">addGlobalUncaughtErrorHandler</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#三、当前倍市得框架使用解析"><span class="level-left"><span class="level-item">3</span><span class="level-item">三、当前倍市得框架使用解析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、主应用"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">1、主应用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#技术解析："><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">技术解析：</span></span></a></li><li><a class="level is-mobile" href="#流程解析："><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">流程解析：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2、子应用"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">2、子应用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#技术解析：-1"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">技术解析：</span></span></a></li><li><a class="level is-mobile" href="#流程解析：-1"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">流程解析：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3、主子项目通信"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">3、主子项目通信</span></span></a></li><li><a class="level is-mobile" href="#4、脚手架"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">4、脚手架</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/ThreeJs/"><span class="level-start"><span class="level-item">ThreeJs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/node/"><span class="level-start"><span class="level-item">node</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/typeScript/"><span class="level-start"><span class="level-item">typeScript</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"><span class="level-start"><span class="level-item">框架</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%9F%B3%E4%B9%90/"><span class="level-start"><span class="level-item">音乐</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ThreeJs/"><span class="tag">ThreeJs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/music/"><span class="tag">music</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/typeScript/"><span class="tag">typeScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A1%86%E6%9E%B6/"><span class="tag">框架</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Cynqu" height="28"></a><p class="is-size-7"><span>&copy; 2021 Cynqu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>